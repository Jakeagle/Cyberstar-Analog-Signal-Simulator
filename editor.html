<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cyberstar Show Editor</title>
    <script src="character-movements.js"></script>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      :root {
        --bg: #0d0d1a;
        --panel: #141428;
        --toolbar: #1a1a2e;
        --border: #2a2a44;
        --text: #c8c8e0;
        --muted: #666680;
        --ruler-bg: #111122;
        --row-bg: #12121f;
        --row-alt: #0f0f1c;
        --row-hover: #1a1a30;
        --sel: #ffffff;
        --ruler-h: 44px;
        --label-w: 200px;
        --char-h: 26px;
        --row-h: 22px;
      }

      html,
      body {
        height: 100%;
        background: var(--bg);
        color: var(--text);
        font-family: "Segoe UI", system-ui, sans-serif;
        font-size: 13px;
        overflow: hidden;
      }

      /* â”€â”€ TOOLBAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #toolbar {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 0 12px;
        height: 46px;
        background: var(--toolbar);
        border-bottom: 1px solid var(--border);
        flex-shrink: 0;
        flex-wrap: nowrap;
        overflow: hidden;
      }

      .tb-group {
        display: flex;
        align-items: center;
        gap: 6px;
        border-right: 1px solid var(--border);
        padding-right: 10px;
      }
      .tb-group:last-child {
        border-right: none;
      }

      .tb-title {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
        padding: 0 8px;
      }
      #show-title {
        font-size: 0.95em;
        font-weight: 600;
        color: #ddeeff;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .band-badge {
        font-size: 0.72em;
        padding: 2px 7px;
        border-radius: 10px;
        font-weight: 700;
        letter-spacing: 1px;
        flex-shrink: 0;
      }
      .band-rock {
        background: rgba(0, 200, 255, 0.15);
        color: #00c8ff;
        border: 1px solid #00c8ff44;
      }
      .band-munch {
        background: rgba(255, 80, 80, 0.15);
        color: #ff8080;
        border: 1px solid #ff808044;
      }

      input[type="file"] {
        display: none;
      }

      .tb-btn {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 5px 10px;
        border: 1px solid var(--border);
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        font-size: 0.82em;
        cursor: pointer;
        text-decoration: none;
        white-space: nowrap;
        transition:
          background 0.15s,
          border-color 0.15s;
      }
      .tb-btn:hover {
        background: rgba(255, 255, 255, 0.09);
        border-color: #555;
      }
      .tb-btn:disabled {
        opacity: 0.4;
        cursor: default;
        pointer-events: none;
      }
      .tb-btn-green {
        border-color: rgba(0, 200, 100, 0.4);
        color: #00d464;
        background: rgba(0, 200, 100, 0.07);
      }
      .tb-btn-green:hover {
        background: rgba(0, 200, 100, 0.15);
        border-color: rgba(0, 200, 100, 0.7);
      }

      .time-display {
        font-family: "Courier New", monospace;
        font-size: 0.82em;
        color: #88aacc;
        background: rgba(0, 0, 0, 0.3);
        padding: 4px 10px;
        border-radius: 4px;
        border: 1px solid var(--border);
        min-width: 160px;
        text-align: center;
      }

      #zoom-label {
        font-family: monospace;
        font-size: 0.8em;
        color: var(--muted);
        min-width: 40px;
        text-align: center;
      }

      /* â”€â”€ APP BODY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #app {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      /* â”€â”€ EMPTY STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #empty-state {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .empty-inner {
        text-align: center;
        max-width: 420px;
      }
      .empty-icon {
        font-size: 4em;
        margin-bottom: 16px;
      }
      .empty-inner h2 {
        font-size: 1.4em;
        color: #ddeeff;
        margin-bottom: 10px;
      }
      .empty-inner p {
        color: var(--muted);
        line-height: 1.6;
        margin-bottom: 8px;
      }
      .empty-inner .tb-btn {
        margin-top: 20px;
        font-size: 0.92em;
        padding: 8px 20px;
      }

      /* â”€â”€ EDITOR BODY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #editor-body {
        flex: 1;
        display: none;
        flex-direction: row;
        overflow: hidden;
        min-height: 0;
      }

      /* â”€â”€ LABEL PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #label-panel {
        width: var(--label-w);
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        border-right: 1px solid var(--border);
        background: var(--panel);
        overflow: hidden;
      }
      #label-corner {
        height: var(--ruler-h);
        flex-shrink: 0;
        background: var(--ruler-bg);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: flex-end;
        padding: 0 10px 6px;
      }
      #label-corner span {
        font-size: 0.72em;
        color: var(--muted);
        letter-spacing: 1px;
        text-transform: uppercase;
      }
      #label-scroll {
        flex: 1;
        overflow: hidden;
      }
      .lbl-char-header {
        display: flex;
        align-items: center;
        padding: 0 10px;
        border-bottom: 1px solid;
        font-size: 0.8em;
        font-weight: 700;
        letter-spacing: 0.5px;
        overflow: hidden;
        height: var(--char-h);
        flex-shrink: 0;
      }
      .lbl-move-row {
        display: flex;
        align-items: center;
        padding: 0 10px 0 18px;
        height: var(--row-h);
        font-family: "Courier New", monospace;
        font-size: 0.74em;
        color: var(--muted);
        border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        background: var(--row-bg);
      }
      .lbl-move-row:nth-child(odd) {
        background: var(--row-alt);
      }

      /* â”€â”€ TIMELINE WRAP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #timeline-wrap {
        flex: 1;
        overflow: auto;
        position: relative;
        min-width: 0;
      }

      #ruler-canvas {
        display: block;
        position: sticky;
        top: 0;
        left: 0;
        z-index: 20;
        cursor: crosshair;
      }

      /* â”€â”€ TRACKS CONTAINER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #tracks-container {
        position: relative;
        min-height: 100px;
      }

      .track-char-header {
        height: var(--char-h);
        display: flex;
        align-items: center;
        padding: 0 14px;
        font-size: 0.75em;
        font-weight: 700;
        letter-spacing: 1px;
        text-transform: uppercase;
        border-bottom: 1px solid;
        position: sticky;
        left: 0;
        z-index: 5;
      }

      .track-row {
        height: var(--row-h);
        position: relative;
        border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        background: var(--row-bg);
        cursor: crosshair;
        user-select: none;
      }
      .track-row:nth-child(odd) {
        background: var(--row-alt);
      }
      .track-row:hover {
        background: var(--row-hover);
      }

      .signal-block {
        position: absolute;
        top: 3px;
        height: calc(var(--row-h) - 6px);
        border-radius: 3px;
        cursor: grab;
        border: 1px solid transparent;
        transition:
          opacity 0.1s,
          border-color 0.1s;
        z-index: 2;
      }
      .signal-block:hover {
        opacity: 1 !important;
        filter: brightness(1.3);
      }
      .signal-block.selected {
        opacity: 1 !important;
        border-color: #fff !important;
        filter: brightness(1.4);
        box-shadow: 0 0 6px rgba(255, 255, 255, 0.4);
      }
      .signal-block.block-dragging {
        opacity: 0.3 !important;
        cursor: grabbing;
      }

      /* â”€â”€ DRAG-SELECT RECTANGLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #select-rect {
        position: absolute;
        top: 0;
        left: 0;
        width: 0;
        height: 100%;
        border: 1.5px solid rgba(100, 200, 255, 0.85);
        background: rgba(100, 200, 255, 0.08);
        pointer-events: none;
        display: none;
        z-index: 12;
        border-radius: 2px;
      }

      /* â”€â”€ SNAP LINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #snap-line {
        position: absolute;
        top: 0;
        width: 1px;
        background: #00ffcc;
        box-shadow: 0 0 5px #00ffcc88;
        pointer-events: none;
        display: none;
        z-index: 20;
      }

      /* â”€â”€ SNAP BUTTON ACTIVE STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      .snap-active {
        border-color: rgba(0, 255, 180, 0.5) !important;
        color: #00ffb0 !important;
        background: rgba(0, 255, 160, 0.08) !important;
      }

      /* â”€â”€ PLAYHEAD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #playhead {
        position: absolute;
        top: 0;
        width: 2px;
        height: 100%;
        background: #ff4444;
        pointer-events: none;
        z-index: 15;
        will-change: left;
      }
      #playhead::before {
        content: "";
        position: absolute;
        top: 0;
        left: -4px;
        border: 5px solid transparent;
        border-top-color: #ff4444;
      }

      /* â”€â”€ DRAG PREVIEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #drag-preview {
        position: absolute;
        top: 0;
        height: 16px;
        background: rgba(255, 255, 255, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.6);
        border-radius: 3px;
        pointer-events: none;
        z-index: 8;
      }

      /* â”€â”€ STATUS BAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #status-bar {
        height: 26px;
        display: flex;
        align-items: center;
        padding: 0 14px;
        background: var(--toolbar);
        border-top: 1px solid var(--border);
        font-size: 0.78em;
        color: var(--muted);
        flex-shrink: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* â”€â”€ HELP TOOLTIP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #help-bar {
        height: 22px;
        display: flex;
        align-items: center;
        padding: 0 14px;
        background: rgba(0, 0, 0, 0.25);
        font-size: 0.73em;
        color: #44445a;
        gap: 16px;
        flex-shrink: 0;
      }
      #help-bar span {
        white-space: nowrap;
      }
      #help-bar kbd {
        background: #1e1e32;
        border: 1px solid #333;
        border-radius: 3px;
        padding: 0 4px;
        font-size: 0.9em;
        color: #888;
      }

      /* scrollbar styling */
      #timeline-wrap::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      #timeline-wrap::-webkit-scrollbar-track {
        background: #0d0d1a;
      }
      #timeline-wrap::-webkit-scrollbar-thumb {
        background: #2a2a44;
        border-radius: 4px;
      }
      #timeline-wrap::-webkit-scrollbar-thumb:hover {
        background: #3a3a60;
      }
      #timeline-wrap::-webkit-scrollbar-corner {
        background: #0d0d1a;
      }

      /* â”€â”€ NEW SHOW MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #new-show-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.65);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }
      #new-show-overlay.open {
        display: flex;
      }
      #new-show-modal {
        background: #1a1a2e;
        border: 1px solid #2a2a44;
        border-radius: 10px;
        padding: 28px 32px;
        width: 380px;
        max-width: 95vw;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      }
      #new-show-modal h3 {
        font-size: 1.15em;
        color: #ddeeff;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .ns-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 16px;
      }
      .ns-field label {
        font-size: 0.8em;
        color: #888899;
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }
      .ns-field input,
      .ns-field select {
        background: #0d0d1a;
        border: 1px solid #2a2a44;
        border-radius: 5px;
        color: #c8c8e0;
        padding: 7px 10px;
        font-size: 0.92em;
        outline: none;
        transition: border-color 0.15s;
      }
      .ns-field input:focus,
      .ns-field select:focus {
        border-color: #00c8ff88;
      }
      .ns-dur-row {
        display: flex;
        gap: 8px;
      }
      .ns-dur-row input {
        flex: 1;
        text-align: center;
      }
      .ns-dur-sep {
        align-self: center;
        color: #666680;
        font-size: 1.1em;
      }
      .ns-actions {
        display: flex;
        gap: 10px;
        margin-top: 22px;
      }
      .ns-actions button {
        flex: 1;
        padding: 8px;
        border-radius: 5px;
        border: 1px solid #2a2a44;
        cursor: pointer;
        font-size: 0.88em;
        font-weight: 600;
      }
      #ns-create {
        background: rgba(0, 200, 100, 0.12);
        border-color: rgba(0, 200, 100, 0.4);
        color: #00d464;
      }
      #ns-create:hover {
        background: rgba(0, 200, 100, 0.22);
      }
      #ns-cancel {
        background: rgba(255, 255, 255, 0.04);
        color: #888899;
      }
      #ns-cancel:hover {
        background: rgba(255, 255, 255, 0.09);
      }

      /* â”€â”€ SAVED SHOWS MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #saved-shows-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.65);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }
      #saved-shows-overlay.open {
        display: flex;
      }
      #saved-shows-modal {
        background: #1a1a2e;
        border: 1px solid #2a2a44;
        border-radius: 10px;
        padding: 24px 28px;
        width: 520px;
        max-width: 96vw;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      }
      #saved-shows-modal h3 {
        font-size: 1.1em;
        color: #ddeeff;
        margin-bottom: 16px;
        flex-shrink: 0;
      }
      #ss-list {
        overflow-y: auto;
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 60px;
        padding-right: 4px;
      }
      #ss-list::-webkit-scrollbar {
        width: 6px;
      }
      #ss-list::-webkit-scrollbar-track {
        background: #0d0d1a;
      }
      #ss-list::-webkit-scrollbar-thumb {
        background: #2a2a44;
        border-radius: 3px;
      }
      .ss-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid #2a2a44;
        border-radius: 6px;
        padding: 10px 12px;
      }
      .ss-item:hover {
        border-color: #3a3a60;
      }
      .ss-item-info {
        display: flex;
        flex-direction: column;
        gap: 3px;
        min-width: 0;
      }
      .ss-item-title {
        font-size: 0.92em;
        font-weight: 600;
        color: #c8c8e0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .ss-item-meta {
        font-size: 0.75em;
        color: #555570;
      }
      .ss-item-actions {
        display: flex;
        gap: 6px;
        flex-shrink: 0;
      }
      #ss-close-row {
        margin-top: 14px;
        display: flex;
        justify-content: flex-end;
        flex-shrink: 0;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <!-- â”€â”€ TOOLBAR â”€â”€ -->
      <div id="toolbar">
        <div class="tb-group">
          <button id="btn-new-show" class="tb-btn tb-btn-green">
            âœš New Show
          </button>
          <label for="json-input" class="tb-btn">ğŸ“‚ Load Show</label>
          <input type="file" id="json-input" accept=".json,.cybershow.json" />
          <button
            id="btn-save"
            class="tb-btn"
            disabled
            title="Save to browser local storage (Ctrl+S)"
          >
            ğŸ’¾ Save
          </button>
          <button id="btn-saved-shows" class="tb-btn">ğŸ“ Saved Shows</button>
          <label for="wav-input" class="tb-btn">ğŸµ Load WAV</label>
          <input type="file" id="wav-input" accept=".wav,audio/*" />
        </div>

        <div class="tb-title">
          <span id="show-title">No show loaded</span>
          <span id="band-badge" class="band-badge" style="display: none"></span>
        </div>

        <div class="tb-group tb-transport">
          <button id="btn-play" class="tb-btn" disabled>â–¶ Play</button>
          <button id="btn-pause" class="tb-btn" disabled>â¸ Pause</button>
          <button id="btn-stop" class="tb-btn" disabled>â¹ Stop</button>
          <button
            id="btn-snap"
            class="tb-btn snap-active"
            title="Snap to frames / block edges / time marks â€” hold Shift to bypass (S)"
          >
            ğŸ”’ Snap
          </button>
          <span id="time-display" class="time-display">0:00.000 / F0</span>
        </div>

        <div class="tb-group">
          <button
            id="btn-zoom-out"
            class="tb-btn"
            title="Zoom out (scroll left/right to navigate)"
          >
            âˆ’
          </button>
          <span id="zoom-label">5px/fr</span>
          <button id="btn-zoom-in" class="tb-btn" title="Zoom in">+</button>
        </div>

        <div class="tb-group">
          <button id="btn-export" class="tb-btn tb-btn-green" disabled>
            â¬‡ Export JSON
          </button>
          <a href="index.html" class="tb-btn">â† Simulator</a>
        </div>
      </div>

      <!-- â”€â”€ EMPTY STATE â”€â”€ -->
      <div id="empty-state">
        <div class="empty-inner">
          <div class="empty-icon">ğŸ¬</div>
          <h2>Cyberstar Show Editor</h2>
          <p>
            Start a brand-new show, or open an existing
            <strong>.cybershow.json</strong> file.
          </p>
          <div
            style="
              display: flex;
              gap: 12px;
              justify-content: center;
              margin-top: 22px;
              flex-wrap: wrap;
            "
          >
            <button
              id="btn-new-show-empty"
              class="tb-btn tb-btn-green"
              style="padding: 10px 24px; font-size: 0.95em"
            >
              âœš New Show
            </button>
            <label
              for="json-input-2"
              class="tb-btn"
              style="padding: 10px 24px; font-size: 0.95em; cursor: pointer"
              >ğŸ“‚ Load Show JSON</label
            >
          </div>
          <input type="file" id="json-input-2" accept=".json,.cybershow.json" />
          <p style="margin-top: 18px; font-size: 0.82em">
            Load a WAV file after opening a show to audition while you edit.
          </p>
        </div>
      </div>

      <!-- â”€â”€ EDITOR BODY â”€â”€ -->
      <div id="editor-body">
        <!-- Label column (character names + movement names) -->
        <div id="label-panel">
          <div id="label-corner"><span>Characters</span></div>
          <div id="label-scroll"></div>
        </div>

        <!-- Timeline (ruler + tracks, scrollable) -->
        <div id="timeline-wrap">
          <canvas id="ruler-canvas" title="Click to seek"></canvas>
          <div id="tracks-container">
            <div id="playhead"></div>
            <div id="drag-preview"></div>
            <div id="snap-line"></div>
          </div>
        </div>
      </div>

      <!-- â”€â”€ SAVED SHOWS MODAL â”€â”€ -->
      <div id="saved-shows-overlay">
        <div id="saved-shows-modal">
          <h3>ğŸ“ Saved Shows</h3>
          <div id="ss-list"></div>
          <div id="ss-close-row">
            <button id="ss-close" class="tb-btn">Close</button>
          </div>
        </div>
      </div>

      <!-- â”€â”€ NEW SHOW MODAL â”€â”€ -->
      <div id="new-show-overlay">
        <div id="new-show-modal">
          <h3>âœš New Show</h3>
          <div class="ns-field">
            <label for="ns-title">Show Title</label>
            <input
              id="ns-title"
              type="text"
              placeholder="My Cyberstar Show"
              maxlength="80"
            />
          </div>
          <div class="ns-field">
            <label for="ns-band">Band</label>
            <select id="ns-band">
              <option value="rock">Rock-afire Explosion (RFE)</option>
              <option value="munch">Munch's Make Believe Band (MMBB)</option>
            </select>
          </div>
          <div class="ns-field">
            <label>Duration</label>
            <div class="ns-dur-row">
              <input
                id="ns-dur-min"
                type="number"
                min="0"
                max="59"
                value="3"
                title="Minutes"
              />
              <span class="ns-dur-sep">m</span>
              <input
                id="ns-dur-sec"
                type="number"
                min="0"
                max="59"
                value="30"
                title="Seconds"
              />
              <span class="ns-dur-sep">s</span>
            </div>
          </div>
          <div class="ns-actions">
            <button id="ns-create">Create Show</button>
            <button id="ns-cancel">Cancel</button>
          </div>
        </div>
      </div>

      <!-- â”€â”€ HELP BAR â”€â”€ -->
      <div id="help-bar">
        <span><kbd>Drag</kbd> row â†’ create block</span>
        <span><kbd>Ctrl+Drag</kbd> â†’ marquee select</span>
        <span><kbd>Ctrl+Click</kbd> block â†’ add to selection</span>
        <span><kbd>Del</kbd> â†’ remove selected</span>
        <span
          ><kbd>Ctrl+C</kbd> copy &ensp; <kbd>Ctrl+V</kbd> paste at playhead
          &ensp; <kbd>Ctrl+D</kbd> duplicate</span
        >
        <span><kbd>Click</kbd> ruler â†’ seek</span>
        <span
          ><kbd>Space</kbd> play/pause &ensp; <kbd>S</kbd> snap &ensp;
          <kbd>Shift</kbd>+drag bypass snap</span
        >
      </div>

      <!-- â”€â”€ STATUS BAR â”€â”€ -->
      <div id="status-bar">Ready â€” load a show to begin.</div>
    </div>
    <!-- #app -->

    <script>
      /* ============================================================
   CONSTANTS
   ============================================================ */
      const FPS = 50;
      const MS_PER_FRAME = 1000 / FPS; // 20 ms
      const RULER_H = 44;
      const CHAR_H = 26;
      const ROW_H = 22;

      const BAND_ORDER = {
        rock: [
          "Rolfe",
          "Earl",
          "Dook LaRue",
          "Fatz",
          "Beach Bear",
          "Looney Bird",
          "Mitzi",
          "Billy Bob",
          "Lights",
        ],
        munch: [
          "Chuck E. Cheese",
          "Munch",
          "Helen Henny",
          "Jasper T. Jowls",
          "Pasqually",
        ],
      };

      const CHAR_COLORS = {
        Rolfe: "#00c8ff",
        Earl: "#ff9800",
        "Dook LaRue": "#4caf50",
        Fatz: "#b44ff4",
        "Beach Bear": "#e91e63",
        "Looney Bird": "#ffe000",
        Mitzi: "#ff6e40",
        "Billy Bob": "#00e5cc",
        Lights: "#aaaaaa",
        "Chuck E. Cheese": "#f44336",
        Munch: "#8bc34a",
        "Helen Henny": "#ff80ab",
        "Jasper T. Jowls": "#ffd740",
        Pasqually: "#40c4ff",
      };

      /* ============================================================
   STATE
   ============================================================ */
      let showData = null;
      let audioBuffer = null;
      let audioCtx = null;
      let sourceNode = null;
      let isPlaying = false;
      let playAudioStart = 0; // audioCtx.currentTime at last play start
      let playFrameStart = 0; // show frame at last play start
      let curFrame = 0;
      let zoom = 5; // px per frame
      let totalFrames = 9000;
      let rowMeta = []; // [{ charName, movKey, color }] in display order
      let charMeta = []; // [{ charName, color, movKeys[] }] in display order
      let selectedKey = null; // "charName||movKey||startFrame" or null (primary selection)
      let selectedKeys = new Set(); // all currently-selected block keys (multi-select)
      let clipboard = null; // { blocks:[{charName,movKey,startFrame,endFrame}], anchorFrame }
      let dragState = null; // { charName, movKey, anchorFrame, curFrame }
      let blockMoveState = null; // { charName, movKey, startFrame, endFrame, dur, grabOffset, el, row, mouseDownX, dragging, mode ('move'|'resize-start'|'resize-end'), previewStart, previewEnd }
      let dragSelectState = null; // { startFrame, curFrame, anchorClientX }
      let snapEnabled = true;
      let rafId = null;

      const SNAP_PX = 12; // pixels â€” snap activation threshold
      const EDGE_PX = 10; // pixels from block edge that triggers resize instead of move

      /* ============================================================
   DOM REFS
   ============================================================ */
      let elEditorBody, elEmptyState, elLabelScroll, elTimelineWrap;
      let elRulerCanvas, elTracks, elPlayhead, elDragPreview, elSnapLine;
      let elStatus, elTimeDisplay, elZoomLabel;
      let elBtnPlay, elBtnPause, elBtnStop, elBtnExport, elBtnSnap;

      /* ============================================================
   UTILITIES
   ============================================================ */
      const frameToMs = (f) => f * MS_PER_FRAME;
      const msToFrame = (ms) => Math.round(ms / MS_PER_FRAME);
      const frameToX = (f) => f * zoom;
      const xToFrame = (x) =>
        Math.max(0, Math.min(totalFrames, Math.round(x / zoom)));

      function frameToTimestamp(f) {
        const ms = frameToMs(f);
        const m = Math.floor(ms / 60000);
        const s = String(Math.floor((ms % 60000) / 1000)).padStart(2, "0");
        const ms3 = String(Math.round(ms % 1000)).padStart(3, "0");
        return `${m}:${s}.${ms3}`;
      }

      function setStatus(msg, color) {
        elStatus.textContent = msg;
        elStatus.style.color = color || "";
      }

      /* ============================================================
   SNAP
   ============================================================ */
      /** Collect all snap-target frames for a given row, excluding one block. */
      function getSnapFrames(charName, movKey, excludeFrom, excludeTo) {
        const targets = new Set();
        // Always snap to start/end of show
        targets.add(0);
        targets.add(totalFrames);

        // Snap interval mirrors the ruler's major-tick interval at current zoom
        const pxPerSec = zoom * FPS;
        const secOptions = [0.1, 0.2, 0.5, 1, 2, 5, 10, 30, 60];
        const majorSec = secOptions.find((s) => s * pxPerSec >= 80) ?? 60;
        const majorF = Math.round(majorSec * FPS);
        for (let f = 0; f <= totalFrames; f += majorF) targets.add(f);

        // Also snap to whole seconds when zoomed in enough
        if (zoom >= 4) {
          for (let f = 0; f <= totalFrames; f += FPS) targets.add(f);
        }

        // Snap to edges of all blocks on this row (excluding the block being moved)
        for (const blk of getBlocks(charName, movKey)) {
          if (blk.startFrame === excludeFrom && blk.endFrame === excludeTo)
            continue;
          targets.add(blk.startFrame);
          targets.add(blk.endFrame);
        }
        return [...targets].sort((a, b) => a - b);
      }

      /** Return the nearest snap frame within SNAP_PX, or rawFrame if none / snap off. */
      function snapFrame(
        rawFrame,
        shiftHeld,
        charName,
        movKey,
        excludeFrom,
        excludeTo,
      ) {
        if (!snapEnabled || shiftHeld) return rawFrame;
        const thresh = Math.max(1, SNAP_PX / zoom);
        const targets = getSnapFrames(charName, movKey, excludeFrom, excludeTo);
        let best = rawFrame,
          bestDist = thresh;
        for (const t of targets) {
          const d = Math.abs(t - rawFrame);
          if (d < bestDist) {
            bestDist = d;
            best = t;
          }
        }
        return best;
      }

      function showSnapLine(frame) {
        if (!elSnapLine) return;
        elSnapLine.style.left = frameToX(frame) + "px";
        elSnapLine.style.height = elTracks.offsetHeight + "px";
        elSnapLine.style.display = "block";
      }

      function hideSnapLine() {
        if (elSnapLine) elSnapLine.style.display = "none";
      }

      function toggleSnap() {
        snapEnabled = !snapEnabled;
        elBtnSnap.classList.toggle("snap-active", snapEnabled);
        elBtnSnap.textContent = snapEnabled ? "ğŸ”’ Snap" : "ğŸ”“ Snap";
        setStatus(
          snapEnabled
            ? "Snap ON â€” blocks will snap to frames, ruler marks, and block edges."
            : "Snap OFF â€” freeform placement.",
        );
      }

      /* ============================================================
   SHOW DATA HELPERS
   ============================================================ */
      function getCharSignals(charName, movKey) {
        if (!showData?.characters?.[charName]) return [];
        return showData.characters[charName].signals.filter(
          (s) => s.movement === movKey,
        );
      }

      function ensureChar(charName) {
        if (!showData.characters[charName]) {
          const cEntry = CHARACTER_MOVEMENTS[charName];
          const track = cEntry
            ? Object.values(cEntry.movements)[0].track
            : "TD";
          showData.characters[charName] = { track, signals: [] };
        }
      }

      function getBit(charName, movKey) {
        return CHARACTER_MOVEMENTS[charName]?.movements?.[movKey]?.bit ?? 0;
      }

      /** Pair ONâ†’OFF signals into renderable blocks */
      function getBlocks(charName, movKey) {
        const sigs = getCharSignals(charName, movKey)
          .slice()
          .sort((a, b) => a.frame - b.frame);
        const blocks = [];
        let onFrame = null;
        for (const s of sigs) {
          if (s.state && onFrame === null) {
            onFrame = s.frame;
          } else if (!s.state && onFrame !== null) {
            blocks.push({ startFrame: onFrame, endFrame: s.frame });
            onFrame = null;
          }
        }
        if (onFrame !== null)
          blocks.push({ startFrame: onFrame, endFrame: totalFrames });
        return blocks;
      }

      /* ============================================================
   NEW SHOW
   ============================================================ */
      function openNewShowModal() {
        document.getElementById("new-show-overlay").classList.add("open");
        // Focus title input after transition
        setTimeout(() => document.getElementById("ns-title").focus(), 50);
      }

      function closeNewShowModal() {
        document.getElementById("new-show-overlay").classList.remove("open");
      }

      function createNewShow() {
        const title =
          document.getElementById("ns-title").value.trim() || "Untitled Show";
        const band = document.getElementById("ns-band").value;
        const mins = Math.max(
          0,
          parseInt(document.getElementById("ns-dur-min").value) || 0,
        );
        const secs = Math.max(
          0,
          Math.min(
            59,
            parseInt(document.getElementById("ns-dur-sec").value) || 0,
          ),
        );
        const durationMs = (mins * 60 + secs) * 1000 || 30000; // default 30s if zero
        const frames = msToFrame(durationMs);

        showData = {
          cyberstar_show: true,
          version: "3.0",
          fps: FPS,
          title,
          band,
          duration_frames: frames,
          duration_ms: durationMs,
          characters: {},
        };

        totalFrames = frames;
        closeNewShowModal();
        buildRowMeta(band);
        buildEditor();

        document.getElementById("show-title").textContent = title;
        const badge = document.getElementById("band-badge");
        badge.textContent = band === "munch" ? "MMBB" : "RFE";
        badge.className = `band-badge band-${band}`;
        badge.style.display = "";
        elBtnExport.disabled = false;

        setStatus(
          `New show "${title}" â€” ${frames} frames (${frameToTimestamp(frames)}). Start drawing signal blocks on the timeline.`,
        );
        document.getElementById("btn-save").disabled = false;
      }

      /* ============================================================
   SHOW LOADING
   ============================================================ */
      function loadShow(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const obj = JSON.parse(e.target.result);
            if (!obj.cyberstar_show)
              throw new Error("Not a valid .cybershow.json file.");

            // Normalise legacy v2.1 (flat sequences[] â†’ characters{})
            if (!obj.characters && Array.isArray(obj.sequences)) {
              obj.characters = {};
              for (const s of obj.sequences) {
                const cEntry = CHARACTER_MOVEMENTS[s.character];
                if (!cEntry?.movements?.[s.movement]) continue;
                if (!obj.characters[s.character]) {
                  obj.characters[s.character] = {
                    track: cEntry.movements[s.movement].track,
                    signals: [],
                  };
                }
                const frame = msToFrame(s.time);
                obj.characters[s.character].signals.push({
                  frame,
                  timestamp: frameToTimestamp(frame),
                  movement: s.movement,
                  bit: cEntry.movements[s.movement].bit,
                  state: s.state,
                  note: s.note || "",
                });
              }
              for (const cd of Object.values(obj.characters)) {
                cd.signals.sort((a, b) => a.frame - b.frame);
              }
            }

            if (!obj.characters)
              throw new Error("No character data found in file.");

            showData = obj;
            totalFrames =
              obj.duration_frames ??
              msToFrame(obj.duration_ms ?? obj.duration ?? 180000);

            const band = obj.band || "rock";
            buildRowMeta(band);
            buildEditor();

            document.getElementById("show-title").textContent =
              obj.title || file.name;
            const badge = document.getElementById("band-badge");
            badge.textContent = band === "munch" ? "MMBB" : "RFE";
            badge.className = `band-badge band-${band}`;
            badge.style.display = "";
            elBtnExport.disabled = false;

            const cueCount = Object.values(obj.characters).reduce(
              (n, c) => n + c.signals.length,
              0,
            );
            setStatus(
              `Loaded "${obj.title || file.name}" â€” ${totalFrames} frames (${frameToTimestamp(totalFrames)}), ${cueCount} signal cues.`,
            );
            document.getElementById("btn-save").disabled = false;
          } catch (err) {
            setStatus(`âœ— ${err.message}`, "#f44");
          }
        };
        reader.readAsText(file);
      }

      /* ============================================================
   ROW / CHAR META
   ============================================================ */
      function buildRowMeta(band) {
        rowMeta = [];
        charMeta = [];
        const order = BAND_ORDER[band] || Object.keys(CHARACTER_MOVEMENTS);
        for (const charName of order) {
          const cEntry = CHARACTER_MOVEMENTS[charName];
          if (!cEntry) continue;
          const movKeys = Object.keys(cEntry.movements);
          const color = CHAR_COLORS[charName] || "#888899";
          charMeta.push({ charName, color, movKeys });
          for (const movKey of movKeys) {
            rowMeta.push({ charName, movKey, color });
          }
        }
      }

      /* ============================================================
   EDITOR CONSTRUCTION
   ============================================================ */
      function buildEditor() {
        elEditorBody.style.display = "flex";
        elEmptyState.style.display = "none";
        buildLabels();
        buildTracks();
        drawRuler();
        curFrame = 0;
        updatePlayhead();
      }

      function buildLabels() {
        let html = "";
        for (const cm of charMeta) {
          html += `<div class="lbl-char-header" style="height:${CHAR_H}px;border-color:${cm.color}44;background:${cm.color}18;">
               <span style="color:${cm.color};font-size:0.79em;font-weight:700;letter-spacing:.5px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${cm.charName}</span>
             </div>`;
          for (const movKey of cm.movKeys) {
            html += `<div class="lbl-move-row" style="height:${ROW_H}px;">${movKey.replace(/_/g, " ")}</div>`;
          }
        }
        elLabelScroll.innerHTML = html;
      }

      function buildTracks() {
        const totalW = frameToX(totalFrames) + 300;
        elTracks.style.width = totalW + "px";

        // Clear existing tracks but keep playhead + drag-preview
        for (const el of [...elTracks.children]) {
          if (
            el.id !== "playhead" &&
            el.id !== "drag-preview" &&
            el.id !== "snap-line"
          )
            el.remove();
        }

        const frag = document.createDocumentFragment();
        for (const cm of charMeta) {
          const hdr = document.createElement("div");
          hdr.className = "track-char-header";
          hdr.style.cssText = `height:${CHAR_H}px;width:${totalW}px;border-color:${cm.color}33;background:${cm.color}0e;color:${cm.color}77;`;
          hdr.textContent = cm.charName;
          frag.appendChild(hdr);

          for (const movKey of cm.movKeys) {
            const row = document.createElement("div");
            row.className = "track-row";
            row.dataset.char = cm.charName;
            row.dataset.mov = movKey;
            row.style.cssText = `height:${ROW_H}px;width:${totalW}px;`;
            row.addEventListener("mousedown", onRowMouseDown);
            frag.appendChild(row);
          }
        }
        elTracks.appendChild(frag);

        // Populate signal blocks
        for (const { charName, movKey, color } of rowMeta) {
          renderBlocks(charName, movKey, color);
        }
      }

      function renderBlocks(charName, movKey, color) {
        const row = elTracks.querySelector(
          `.track-row[data-char="${CSS.escape(charName)}"][data-mov="${CSS.escape(movKey)}"]`,
        );
        if (!row) return;

        for (const b of row.querySelectorAll(".signal-block")) b.remove();

        for (const blk of getBlocks(charName, movKey)) {
          const x = frameToX(blk.startFrame);
          const w = Math.max(3, frameToX(blk.endFrame) - x);
          const key = `${charName}||${movKey}||${blk.startFrame}`;

          const el = document.createElement("div");
          el.className = "signal-block";
          el.dataset.key = key;
          el.style.cssText = `left:${x}px;width:${w}px;background:${color};`;
          el.title = `${charName} / ${movKey.replace(/_/g, " ")}\nON: F${blk.startFrame} (${frameToTimestamp(blk.startFrame)})\nOFF: F${blk.endFrame} (${frameToTimestamp(blk.endFrame)})\nDrag middle â†’ move  |  Drag edge â†’ resize  |  Del â†’ remove`;
          // Dynamic cursor: ew-resize near edges, grab in middle
          el.addEventListener("mousemove", (ev) => {
            const ex = ev.offsetX;
            const bw = el.offsetWidth;
            if (ex < EDGE_PX || bw - ex < EDGE_PX)
              el.style.cursor = "ew-resize";
            else el.style.cursor = "grab";
          });
          el.addEventListener("mouseleave", () => {
            el.style.cursor = "";
          });
          el.addEventListener("mousedown", (e) => {
            if (e.button !== 0) return;
            e.stopPropagation();
            e.preventDefault();
            // Ctrl+click â†’ toggle this block in the multi-selection (no drag)
            if (e.ctrlKey || e.metaKey) {
              toggleBlockInSelection(key, el);
              return;
            }
            selectBlock(key, el);
            const bw = el.offsetWidth;
            const ex = e.offsetX;
            const mode =
              ex < EDGE_PX
                ? "resize-start"
                : bw - ex < EDGE_PX
                  ? "resize-end"
                  : "move";
            blockMoveState = {
              charName,
              movKey,
              startFrame: blk.startFrame,
              endFrame: blk.endFrame,
              dur: blk.endFrame - blk.startFrame,
              el,
              row,
              mouseDownX: e.clientX,
              dragging: false,
              mode,
              previewStart: undefined,
              previewEnd: undefined,
            };
          });
          row.appendChild(el);
        }
      }

      function refreshRow(charName, movKey) {
        const meta = rowMeta.find(
          (r) => r.charName === charName && r.movKey === movKey,
        );
        renderBlocks(charName, movKey, meta?.color || "#888");
      }

      /* ============================================================
   SELECTION
   ============================================================ */
      function selectBlock(key, el) {
        clearSelection();
        selectedKey = key;
        selectedKeys.add(key);
        el.classList.add("selected");
        const [cn, mk, sf] = key.split("||");
        setStatus(
          `Selected: ${cn} / ${mk.replace(/_/g, " ")} â€” F${sf} â€” Ctrl+C copy Â· Ctrl+D duplicate Â· Del remove`,
        );
      }

      function toggleBlockInSelection(key, el) {
        if (selectedKeys.has(key)) {
          selectedKeys.delete(key);
          el.classList.remove("selected");
          if (selectedKey === key)
            selectedKey = selectedKeys.size > 0 ? [...selectedKeys][0] : null;
        } else {
          selectedKeys.add(key);
          selectedKey = key;
          el.classList.add("selected");
        }
        const n = selectedKeys.size;
        if (n === 0) {
          setStatus("No blocks selected.");
        } else if (n === 1) {
          const [cn, mk, sf] = [...selectedKeys][0].split("||");
          setStatus(
            `Selected: ${cn} / ${mk.replace(/_/g, " ")} â€” F${sf} â€” Ctrl+C copy Â· Del remove`,
          );
        } else {
          setStatus(
            `${n} blocks selected â€” Ctrl+C copy, Ctrl+D duplicate, Del delete all.`,
          );
        }
      }

      function clearSelection() {
        selectedKey = null;
        selectedKeys.clear();
        for (const b of elTracks.querySelectorAll(".signal-block.selected")) {
          b.classList.remove("selected");
        }
      }

      function deleteSelected() {
        if (selectedKeys.size === 0) return;
        const toDelete = [...selectedKeys].map((k) => {
          const [charName, movKey, sfStr] = k.split("||");
          return { charName, movKey, startFrame: parseInt(sfStr, 10) };
        });
        const affectedRows = new Set();
        for (const { charName, movKey, startFrame } of toDelete) {
          const sigs = showData?.characters?.[charName]?.signals;
          if (!sigs) continue;
          let onIdx = -1,
            offIdx = -1;
          for (let i = 0; i < sigs.length; i++) {
            if (
              sigs[i].movement === movKey &&
              sigs[i].state === true &&
              sigs[i].frame === startFrame
            )
              onIdx = i;
          }
          if (onIdx >= 0) {
            for (let i = onIdx + 1; i < sigs.length; i++) {
              if (sigs[i].movement === movKey && sigs[i].state === false) {
                offIdx = i;
                break;
              }
            }
          }
          const toRemove = [onIdx, offIdx]
            .filter((i) => i >= 0)
            .sort((a, b) => b - a);
          for (const idx of toRemove) sigs.splice(idx, 1);
          affectedRows.add(`${charName}||${movKey}`);
        }
        const n = toDelete.length;
        clearSelection();
        for (const rowKey of affectedRows) {
          const [cn, mk] = rowKey.split("||");
          refreshRow(cn, mk);
        }
        setStatus(`Removed ${n} block${n === 1 ? "" : "s"}.`);
      }

      /* ============================================================
   COPY / PASTE
   ============================================================ */
      function getSelectedBlocks() {
        const result = [];
        for (const key of selectedKeys) {
          const [charName, movKey, sfStr] = key.split("||");
          const startFrame = parseInt(sfStr, 10);
          const blk = getBlocks(charName, movKey).find(
            (b) => b.startFrame === startFrame,
          );
          if (blk)
            result.push({
              charName,
              movKey,
              startFrame: blk.startFrame,
              endFrame: blk.endFrame,
            });
        }
        return result;
      }

      function copySelected() {
        const blocks = getSelectedBlocks();
        if (blocks.length === 0) {
          setStatus("Nothing selected to copy.", "#fa0");
          return;
        }
        const anchorFrame = Math.min(...blocks.map((b) => b.startFrame));
        clipboard = { blocks, anchorFrame };
        setStatus(
          `Copied ${blocks.length} block${blocks.length === 1 ? "" : "s"} â€” Ctrl+V to paste at playhead (F${curFrame}).`,
        );
      }

      function pasteClipboard() {
        if (!clipboard || !showData) {
          setStatus("Nothing to paste.", "#fa0");
          return;
        }
        const offset = curFrame - clipboard.anchorFrame;
        const placed = [];
        const skipped = [];
        for (const blk of clipboard.blocks) {
          const newStart = Math.max(0, blk.startFrame + offset);
          const newEnd = Math.min(totalFrames, blk.endFrame + offset);
          if (newEnd - newStart < 1) {
            skipped.push(blk);
            continue;
          }
          const overlaps = getBlocks(blk.charName, blk.movKey).some(
            (b) => newStart < b.endFrame && newEnd > b.startFrame,
          );
          if (overlaps) {
            skipped.push(blk);
            continue;
          }
          commitInsert(blk.charName, blk.movKey, newStart, newEnd);
          placed.push(`${blk.charName}||${blk.movKey}||${newStart}`);
        }
        if (placed.length === 0) {
          setStatus("âš  Paste: all blocks overlap existing signals.", "#fa0");
          return;
        }
        clearSelection();
        for (const k of placed) {
          selectedKeys.add(k);
          selectedKey = k;
          const el = elTracks.querySelector(
            `.signal-block[data-key="${CSS.escape(k)}"]`,
          );
          if (el) el.classList.add("selected");
        }
        const msg = skipped.length
          ? `Pasted ${placed.length} block${placed.length === 1 ? "" : "s"} (${skipped.length} skipped â€” overlap).`
          : `Pasted ${placed.length} block${placed.length === 1 ? "" : "s"} at F${curFrame}.`;
        setStatus(msg);
      }

      /* ============================================================
   DRAG-SELECT RECT
   ============================================================ */
      function updateSelectRect(startFrame, endFrame) {
        const elRect = document.getElementById("select-rect");
        if (!elRect) return;
        const x1 = frameToX(Math.min(startFrame, endFrame));
        const x2 = frameToX(Math.max(startFrame, endFrame));
        elRect.style.display = "block";
        elRect.style.left = x1 + "px";
        elRect.style.width = Math.max(2, x2 - x1) + "px";
        elRect.style.height =
          Math.max(elTracks.scrollHeight, elTimelineWrap.clientHeight) + "px";
      }

      function hideSelectRect() {
        const elRect = document.getElementById("select-rect");
        if (elRect) elRect.style.display = "none";
      }

      /* ============================================================
   DRAG-TO-CREATE
   ============================================================ */
      function onRowMouseDown(e) {
        if (e.button !== 0) return;
        const row = e.currentTarget;
        const charName = row.dataset.char;
        const movKey = row.dataset.mov;
        const rect = row.getBoundingClientRect();
        const rawX = e.clientX - rect.left + elTimelineWrap.scrollLeft;

        // â”€â”€ Ctrl+drag â†’ marquee selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          const frame = xToFrame(rawX);
          dragSelectState = {
            startFrame: frame,
            curFrame: frame,
            anchorClientX: e.clientX,
          };
          updateSelectRect(frame, frame);
          return;
        }

        const frame = snapFrame(xToFrame(rawX), e.shiftKey, charName, movKey);
        clearSelection();
        dragState = {
          charName,
          movKey,
          anchorFrame: frame,
          curFrame: frame,
          row,
          shiftHeld: e.shiftKey,
        };
        updateDragPreview(row, frame, frame);
        showSnapLine(frame);
        e.preventDefault();
      }

      function onMouseMove(e) {
        /* â”€â”€ Block interaction drag (move / resize-start / resize-end) â”€â”€ */
        if (blockMoveState) {
          const dx = e.clientX - blockMoveState.mouseDownX;
          if (!blockMoveState.dragging) {
            if (Math.abs(dx) < 4) return;
            blockMoveState.dragging = true;
            blockMoveState.el.classList.add("block-dragging");
            if (blockMoveState.mode === "move") {
              // Compute grab offset (frames into the block where user clicked)
              const rowRect = blockMoveState.row.getBoundingClientRect();
              const grabX =
                blockMoveState.mouseDownX -
                rowRect.left +
                elTimelineWrap.scrollLeft;
              blockMoveState.grabOffset =
                xToFrame(grabX) - blockMoveState.startFrame;
            }
          }
          if (blockMoveState.dragging) {
            const { charName, movKey, startFrame, endFrame, dur, mode } =
              blockMoveState;
            const rowRect = blockMoveState.row.getBoundingClientRect();
            const rawX = e.clientX - rowRect.left + elTimelineWrap.scrollLeft;
            const rawFrame = xToFrame(rawX);

            if (mode === "move") {
              const rawStart = rawFrame - blockMoveState.grabOffset;
              const rawEnd = rawStart + dur;
              const snappedStart = snapFrame(
                rawStart,
                e.shiftKey,
                charName,
                movKey,
                startFrame,
                endFrame,
              );
              const snappedEnd = snapFrame(
                rawEnd,
                e.shiftKey,
                charName,
                movKey,
                startFrame,
                endFrame,
              );

              // Track which edges actually snapped and by how much.
              // If an edge didn't snap, snapFrame returns the raw value â†’ distance 0,
              // which would incorrectly beat a real snap on the other edge.
              // Use Infinity for "no snap happened" so the other edge always wins.
              const startDist =
                snappedStart !== rawStart
                  ? Math.abs(snappedStart - rawStart)
                  : Infinity;
              const endDist =
                snappedEnd !== rawEnd
                  ? Math.abs(snappedEnd - rawEnd)
                  : Infinity;

              let finalStart = snappedStart;
              if (endDist < startDist) finalStart = snappedEnd - dur; // end-edge snap wins

              const clampedStart = Math.max(
                0,
                Math.min(totalFrames - dur, finalStart),
              );
              blockMoveState.previewStart = clampedStart;
              blockMoveState.previewEnd = clampedStart + dur;
              // Show snap line at whichever edge is snapped (prefer end if that won)
              const snapLineFrame =
                endDist < startDist ? clampedStart + dur : clampedStart;
              updateDragPreview(
                blockMoveState.row,
                clampedStart,
                clampedStart + dur,
              );
              showSnapLine(snapLineFrame);
            } else if (mode === "resize-start") {
              const snapped = snapFrame(
                rawFrame,
                e.shiftKey,
                charName,
                movKey,
                startFrame,
                endFrame,
              );
              const newStart = Math.max(0, Math.min(endFrame - 1, snapped));
              blockMoveState.previewStart = newStart;
              blockMoveState.previewEnd = endFrame;
              updateDragPreview(blockMoveState.row, newStart, endFrame);
              showSnapLine(newStart);
            } else if (mode === "resize-end") {
              const snapped = snapFrame(
                rawFrame,
                e.shiftKey,
                charName,
                movKey,
                startFrame,
                endFrame,
              );
              const newEnd = Math.max(
                startFrame + 1,
                Math.min(totalFrames, snapped),
              );
              blockMoveState.previewStart = startFrame;
              blockMoveState.previewEnd = newEnd;
              updateDragPreview(blockMoveState.row, startFrame, newEnd);
              showSnapLine(newEnd);
            }
          }
          return;
        }

        /* â”€â”€ Marquee drag-select â”€â”€ */
        if (dragSelectState) {
          const tracksRect = elTracks.getBoundingClientRect();
          const rawX = e.clientX - tracksRect.left + elTimelineWrap.scrollLeft;
          dragSelectState.curFrame = xToFrame(rawX);
          updateSelectRect(
            dragSelectState.startFrame,
            dragSelectState.curFrame,
          );
          return;
        }

        /* â”€â”€ New-block creation drag â”€â”€ */
        if (!dragState) return;
        const row = dragState.row;
        const rect = row.getBoundingClientRect();
        const rawX = e.clientX - rect.left + elTimelineWrap.scrollLeft;
        dragState.curFrame = snapFrame(
          xToFrame(rawX),
          e.shiftKey,
          dragState.charName,
          dragState.movKey,
        );
        const a = Math.min(dragState.anchorFrame, dragState.curFrame);
        const b = Math.max(dragState.anchorFrame, dragState.curFrame);
        updateDragPreview(row, a, b);
        showSnapLine(b);
      }

      function onMouseUp(e) {
        /* â”€â”€ Block-move drag end â”€â”€ */
        if (blockMoveState) {
          const bm = blockMoveState;
          blockMoveState = null;
          hideDragPreview();
          hideSnapLine();

          if (bm.dragging) {
            bm.el.classList.remove("block-dragging");
            if (
              bm.previewStart !== undefined &&
              (bm.previewStart !== bm.startFrame ||
                bm.previewEnd !== bm.endFrame)
            ) {
              // Overlap check â€” exclude the block being moved
              const overlaps = getBlocks(bm.charName, bm.movKey).some((b) => {
                if (
                  b.startFrame === bm.startFrame &&
                  b.endFrame === bm.endFrame
                )
                  return false;
                return (
                  bm.previewStart < b.endFrame && bm.previewEnd > b.startFrame
                );
              });
              if (overlaps) {
                setStatus(
                  "âš  Cannot move block â€” would overlap another signal.",
                  "#fa0",
                );
                refreshRow(bm.charName, bm.movKey);
              } else {
                commitBlockMove(
                  bm.charName,
                  bm.movKey,
                  bm.startFrame,
                  bm.endFrame,
                  bm.previewStart,
                  bm.previewEnd,
                );
              }
            } else {
              refreshRow(bm.charName, bm.movKey); // re-render to remove dragging class
            }
          }
          return;
        }

        /* â”€â”€ Marquee drag-select end â”€â”€ */
        if (dragSelectState) {
          const ds = dragSelectState;
          dragSelectState = null;
          hideSelectRect();
          const frameA = Math.min(ds.startFrame, ds.curFrame);
          const frameB = Math.max(ds.startFrame, ds.curFrame);
          if (frameB - frameA >= 1) {
            clearSelection();
            let count = 0;
            for (const { charName, movKey } of rowMeta) {
              for (const blk of getBlocks(charName, movKey)) {
                if (blk.startFrame < frameB && blk.endFrame > frameA) {
                  const k = `${charName}||${movKey}||${blk.startFrame}`;
                  selectedKeys.add(k);
                  selectedKey = k;
                  count++;
                  const el = elTracks.querySelector(
                    `.signal-block[data-key="${CSS.escape(k)}"]`,
                  );
                  if (el) el.classList.add("selected");
                }
              }
            }
            setStatus(
              count === 0
                ? "Drag-select: no blocks in range."
                : `Selected ${count} block${count === 1 ? "" : "s"} â€” Ctrl+C copy, Ctrl+D duplicate, Del delete.`,
            );
          }
          return;
        }

        /* â”€â”€ New-block creation drag end â”€â”€ */
        if (!dragState) return;
        const { charName, movKey, anchorFrame, curFrame: cf, row } = dragState;
        let startFrame = Math.min(anchorFrame, cf);
        let endFrame = Math.max(anchorFrame, cf);
        if (endFrame - startFrame < 1) endFrame = startFrame + 1;
        endFrame = Math.min(endFrame, totalFrames);

        hideDragPreview();
        hideSnapLine();
        dragState = null;

        if (startFrame >= endFrame) return;

        // Overlap check
        const overlaps = getBlocks(charName, movKey).some(
          (b) => startFrame < b.endFrame && endFrame > b.startFrame,
        );
        if (overlaps) {
          setStatus(
            "âš  Cannot place block â€” overlaps an existing signal. Select and delete the existing block first.",
            "#fa0",
          );
          return;
        }

        commitInsert(charName, movKey, startFrame, endFrame);
      }

      /* ============================================================
   BLOCK MOVE
   ============================================================ */
      function commitBlockMove(
        charName,
        movKey,
        oldStart,
        oldEnd,
        newStart,
        newEnd,
      ) {
        const sigs = showData?.characters?.[charName]?.signals;
        if (!sigs) return;

        // Find the exact ON signal at oldStart and its matching OFF at oldEnd
        let onIdx = -1,
          offIdx = -1;
        for (let i = 0; i < sigs.length; i++) {
          if (
            sigs[i].movement === movKey &&
            sigs[i].frame === oldStart &&
            sigs[i].state === true
          )
            onIdx = i;
        }
        if (onIdx >= 0) {
          for (let i = onIdx + 1; i < sigs.length; i++) {
            if (
              sigs[i].movement === movKey &&
              sigs[i].frame === oldEnd &&
              sigs[i].state === false
            ) {
              offIdx = i;
              break;
            }
          }
        }
        if (onIdx < 0 || offIdx < 0) {
          setStatus("âœ— Could not locate signals to move.", "#f44");
          refreshRow(charName, movKey);
          return;
        }

        sigs[onIdx].frame = newStart;
        sigs[onIdx].timestamp = frameToTimestamp(newStart);
        sigs[offIdx].frame = newEnd;
        sigs[offIdx].timestamp = frameToTimestamp(newEnd);
        sigs.sort((a, b) => a.frame - b.frame || (a.state ? 1 : -1));

        selectedKey = `${charName}||${movKey}||${newStart}`;
        refreshRow(charName, movKey);

        // Re-apply selection highlight on the moved block
        const movedEl = elTracks.querySelector(
          `.signal-block[data-key="${CSS.escape(selectedKey)}"]`,
        );
        if (movedEl) movedEl.classList.add("selected");

        setStatus(
          `Moved: ${charName} / ${movKey.replace(/_/g, " ")} â†’ F${newStart}â€“F${newEnd} (${frameToTimestamp(newStart)} â€“ ${frameToTimestamp(newEnd)})`,
        );
      }

      function commitInsert(charName, movKey, startFrame, endFrame) {
        ensureChar(charName);
        const bit = getBit(charName, movKey);
        const sigs = showData.characters[charName].signals;
        sigs.push({
          frame: startFrame,
          timestamp: frameToTimestamp(startFrame),
          movement: movKey,
          bit,
          state: true,
          note: "",
        });
        sigs.push({
          frame: endFrame,
          timestamp: frameToTimestamp(endFrame),
          movement: movKey,
          bit,
          state: false,
          note: "",
        });
        sigs.sort((a, b) => a.frame - b.frame || (a.state ? 1 : -1));
        refreshRow(charName, movKey);
        setStatus(
          `Added: ${charName} / ${movKey.replace(/_/g, " ")} F${startFrame}â€“F${endFrame} (${frameToTimestamp(startFrame)} â€“ ${frameToTimestamp(endFrame)})`,
        );
      }

      function updateDragPreview(row, startFrame, endFrame) {
        const x = frameToX(startFrame);
        const w = Math.max(3, frameToX(endFrame) - x);
        elDragPreview.style.display = "block";
        elDragPreview.style.left = x + "px";
        elDragPreview.style.top = row.offsetTop + 3 + "px";
        elDragPreview.style.width = w + "px";
        elDragPreview.style.height = ROW_H - 6 + "px";
      }

      function hideDragPreview() {
        elDragPreview.style.display = "none";
      }

      /* ============================================================
   RULER  (windowed â€“ canvas is only viewport-wide to avoid the
           ~65 535 px browser canvas hardware limit)
   ============================================================ */
      function drawRuler() {
        const canvas = elRulerCanvas;

        // Width = visible viewport only; full timeline width lives in
        // elTracks.style.width so the scrollbar stays correct.
        const viewW = Math.max(100, elTimelineWrap.clientWidth || 800);
        const scrollX = elTimelineWrap.scrollLeft || 0;

        canvas.width = viewW; // safe â€” never exceeds screen width
        canvas.height = RULER_H;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#111122";
        ctx.fillRect(0, 0, viewW, RULER_H);

        // Choose a nice tick interval so major ticks are ~80â€“200px apart
        const pxPerSec = zoom * FPS;
        const secOptions = [0.1, 0.2, 0.5, 1, 2, 5, 10, 30, 60];
        const majorSec = secOptions.find((s) => s * pxPerSec >= 80) ?? 60;
        const minorSec = majorSec / 4;
        const majorF = Math.round(majorSec * FPS);
        const minorF = Math.max(1, Math.round(minorSec * FPS));

        // Only iterate over frames that are actually visible
        const firstVisF = Math.max(
          0,
          Math.floor(xToFrame(scrollX) / minorF) * minorF - minorF,
        );
        const lastVisF = Math.min(
          totalFrames + majorF,
          Math.ceil(xToFrame(scrollX + viewW) / minorF) * minorF + minorF,
        );

        ctx.lineWidth = 1;
        for (let f = firstVisF; f <= lastVisF; f += minorF) {
          // Offset by scrollX so ticks land at the correct visual position
          const x = frameToX(f) - scrollX + 0.5;
          const isMajor = f % majorF === 0;

          ctx.strokeStyle = isMajor ? "#4a4a6a" : "#252538";
          ctx.beginPath();
          ctx.moveTo(x, RULER_H);
          ctx.lineTo(x, isMajor ? RULER_H - 18 : RULER_H - 8);
          ctx.stroke();

          if (isMajor) {
            const ms = frameToMs(f);
            const m = Math.floor(ms / 60000);
            const s = String(Math.floor((ms % 60000) / 1000)).padStart(2, "0");
            const ms3 = String(Math.round(ms % 1000)).padStart(3, "0");
            ctx.fillStyle = "#9090b8";
            ctx.font = `11px 'Courier New', monospace`;
            ctx.textAlign = "left";
            ctx.fillText(`${m}:${s}`, x + 3, 14);
            ctx.fillStyle = "#44445a";
            ctx.fillText(`F${f}`, x + 3, 28);
          }
        }

        // Bottom edge line (spans the viewport, not the whole timeline)
        ctx.strokeStyle = "#22223a";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, RULER_H - 0.5);
        ctx.lineTo(viewW, RULER_H - 0.5);
        ctx.stroke();
      }

      /* ============================================================
   PLAYHEAD
   ============================================================ */
      function updatePlayhead() {
        elPlayhead.style.left = frameToX(curFrame) + "px";
        const ms = frameToMs(curFrame);
        const m = Math.floor(ms / 60000);
        const s = String(Math.floor((ms % 60000) / 1000)).padStart(2, "0");
        const ms3 = String(Math.round(ms % 1000)).padStart(3, "0");
        elTimeDisplay.textContent = `${m}:${s}.${ms3}  /  F${curFrame}`;
      }

      function seekToFrame(frame) {
        const wasPlaying = isPlaying;
        if (wasPlaying) stopPlayback(false);
        curFrame = Math.max(0, Math.min(totalFrames, frame));
        updatePlayhead();
        if (wasPlaying) startPlayback();
      }

      /* ============================================================
   AUDIO
   ============================================================ */
      function getAudioCtx() {
        if (!audioCtx || audioCtx.state === "closed")
          audioCtx = new AudioContext();
        return audioCtx;
      }

      function loadWAV(file) {
        setStatus("Decoding audioâ€¦");
        const reader = new FileReader();
        reader.onload = (e) => {
          getAudioCtx()
            .decodeAudioData(e.target.result.slice(0))
            .then((buf) => {
              audioBuffer = buf;
              enableTransport(true);
              setStatus(
                `WAV loaded: ${buf.duration.toFixed(2)}s â€” ${buf.numberOfChannels}ch @ ${buf.sampleRate}Hz`,
              );
            })
            .catch(() =>
              setStatus(
                "âœ— Could not decode audio. Use a standard WAV file.",
                "#f44",
              ),
            );
        };
        reader.readAsArrayBuffer(file);
      }

      function enableTransport(on) {
        elBtnPlay.disabled = !on;
        elBtnPause.disabled = !on;
        elBtnStop.disabled = !on;
      }

      function startPlayback() {
        if (!audioBuffer) {
          setStatus("Load a WAV file to enable playback.", "#fa0");
          return;
        }
        const ctx = getAudioCtx();
        const offsetS = frameToMs(curFrame) / 1000;
        if (offsetS >= audioBuffer.duration) {
          stopPlayback();
          return;
        }

        if (sourceNode) {
          try {
            sourceNode.stop();
          } catch (_) {}
        }
        sourceNode = ctx.createBufferSource();
        sourceNode.buffer = audioBuffer;
        sourceNode.connect(ctx.destination);
        sourceNode.start(0, offsetS);
        sourceNode.onended = () => {
          isPlaying = false;
          cancelAnimationFrame(rafId);
          if (audioBuffer) elBtnPlay.disabled = false;
        };

        playAudioStart = ctx.currentTime;
        playFrameStart = curFrame;
        isPlaying = true;
        elBtnPlay.disabled = true;

        const tick = () => {
          const elapsed = ctx.currentTime - playAudioStart;
          curFrame = Math.min(
            totalFrames,
            playFrameStart + msToFrame(elapsed * 1000),
          );
          updatePlayhead();

          // Auto-scroll playhead into view
          const phX = frameToX(curFrame);
          const wLeft = elTimelineWrap.scrollLeft;
          const wW = elTimelineWrap.clientWidth;
          if (phX > wLeft + wW - 80 || phX < wLeft) {
            elTimelineWrap.scrollLeft = phX - 60;
          }

          if (isPlaying && curFrame < totalFrames)
            rafId = requestAnimationFrame(tick);
        };
        rafId = requestAnimationFrame(tick);
      }

      function pausePlayback() {
        if (!isPlaying) return;
        isPlaying = false;
        cancelAnimationFrame(rafId);
        if (sourceNode) {
          try {
            sourceNode.stop();
          } catch (_) {}
          sourceNode = null;
        }
        if (audioBuffer) elBtnPlay.disabled = false;
      }

      function stopPlayback(resetFrame = true) {
        pausePlayback();
        if (resetFrame) {
          curFrame = 0;
          updatePlayhead();
        }
      }

      /* ============================================================
   ZOOM
   ============================================================ */
      function applyZoom(newZoom) {
        const anchorFrame = curFrame;
        zoom = Math.max(1, Math.min(40, newZoom));
        elZoomLabel.textContent = `${zoom}px/fr`;

        const totalW = frameToX(totalFrames) + 300;
        elTracks.style.width = totalW + "px";
        for (const el of elTracks.querySelectorAll(
          ".track-row, .track-char-header",
        )) {
          el.style.width = totalW + "px";
        }

        drawRuler();
        for (const { charName, movKey, color } of rowMeta)
          renderBlocks(charName, movKey, color);
        updatePlayhead();

        // Keep the current playhead roughly centred after zoom
        elTimelineWrap.scrollLeft = Math.max(
          0,
          frameToX(anchorFrame) - elTimelineWrap.clientWidth / 2,
        );
      }

      /* ============================================================
   EXPORT
   ============================================================ */
      function exportJSON() {
        if (!showData) return;

        // Refresh timestamps
        for (const cd of Object.values(showData.characters)) {
          for (const sig of cd.signals)
            sig.timestamp = frameToTimestamp(sig.frame);
        }
        showData.version = "3.0";
        showData.fps = FPS;
        showData.duration_frames = totalFrames;
        showData.duration_ms = frameToMs(totalFrames);

        const json = JSON.stringify(showData, null, 2);
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${(showData.title || "show").replace(/[^a-z0-9_\-]/gi, "_")}.cybershow.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 10000);

        const total = Object.values(showData.characters).reduce(
          (n, c) => n + Math.floor(c.signals.filter((s) => s.state).length),
          0,
        );
        setStatus(`Exported "${showData.title}" â€” ${total} ON signals.`);
      }

      /* ============================================================
   LOCAL STORAGE â€” SAVE / LOAD
   ============================================================ */
      const LS_PREFIX = "cyberstar_show::";

      function lsSlug(title) {
        return (
          LS_PREFIX +
          (title || "untitled").replace(/[^a-z0-9_\-]/gi, "_").toLowerCase()
        );
      }

      function getAllSavedKeys() {
        return Object.keys(localStorage)
          .filter((k) => k.startsWith(LS_PREFIX))
          .sort();
      }

      function saveToLocalStorage() {
        if (!showData) return;
        for (const cd of Object.values(showData.characters))
          for (const sig of cd.signals)
            sig.timestamp = frameToTimestamp(sig.frame);
        showData.version = "3.0";
        showData.fps = FPS;
        showData.duration_frames = totalFrames;
        showData.duration_ms = frameToMs(totalFrames);
        showData.savedAt = new Date().toISOString();
        const key = lsSlug(showData.title);
        try {
          localStorage.setItem(key, JSON.stringify(showData));
          setStatus(`ğŸ’¾ Saved "${showData.title}" to browser storage.`);
        } catch (_) {
          setStatus("âœ— Could not save â€” browser storage may be full.", "#f44");
        }
      }

      function loadFromLocalStorage(key) {
        try {
          const obj = JSON.parse(localStorage.getItem(key));
          if (!obj || !obj.cyberstar_show)
            throw new Error("Invalid show data.");
          showData = obj;
          totalFrames =
            obj.duration_frames ?? msToFrame(obj.duration_ms ?? 180000);
          const band = obj.band || "rock";
          buildRowMeta(band);
          buildEditor();
          document.getElementById("show-title").textContent =
            obj.title || "Untitled";
          const badge = document.getElementById("band-badge");
          badge.textContent = band === "munch" ? "MMBB" : "RFE";
          badge.className = `band-badge band-${band}`;
          badge.style.display = "";
          elBtnExport.disabled = false;
          document.getElementById("btn-save").disabled = false;
          const cueCount = Object.values(obj.characters).reduce(
            (n, c) => n + c.signals.length,
            0,
          );
          setStatus(
            `Loaded "${obj.title}" from browser storage â€” ${totalFrames} frames, ${cueCount} signal cues.`,
          );
        } catch (err) {
          setStatus(`âœ— ${err.message}`, "#f44");
        }
      }

      function deleteFromLocalStorage(key) {
        try {
          const data = JSON.parse(localStorage.getItem(key));
          const title = data?.title || key;
          localStorage.removeItem(key);
          setStatus(`Deleted "${title}" from browser storage.`);
        } catch (_) {
          localStorage.removeItem(key);
        }
      }

      function openSavedShowsModal() {
        const list = document.getElementById("ss-list");
        const keys = getAllSavedKeys();
        list.innerHTML = "";

        if (keys.length === 0) {
          list.innerHTML =
            '<p style="color:#555570;text-align:center;padding:24px 0;">No saved shows yet.<br><br>Open a show and click ğŸ’¾ Save to save it here.</p>';
        } else {
          for (const key of keys) {
            try {
              const data = JSON.parse(localStorage.getItem(key));
              const savedAt = data.savedAt
                ? new Date(data.savedAt).toLocaleString()
                : "Unknown date";
              const dur = frameToTimestamp(data.duration_frames || 0);
              const bandLabel = data.band === "munch" ? "MMBB" : "RFE";
              const item = document.createElement("div");
              item.className = "ss-item";
              item.innerHTML = `
                <div class="ss-item-info">
                  <span class="ss-item-title">${data.title || "(Untitled)"}</span>
                  <span class="ss-item-meta">${bandLabel} &middot; ${dur} &middot; Saved ${savedAt}</span>
                </div>
                <div class="ss-item-actions">
                  <button class="tb-btn" data-load="${key}">Open</button>
                  <button class="tb-btn" style="color:#ff6666;border-color:#ff444433;" data-del="${key}" title="Delete save">âœ•</button>
                </div>`;
              list.appendChild(item);
            } catch (_) {}
          }
        }

        list._ssHandler && list.removeEventListener("click", list._ssHandler);
        list._ssHandler = (e) => {
          const loadKey = e.target.closest("[data-load]")?.dataset.load;
          const delKey = e.target.closest("[data-del]")?.dataset.del;
          if (loadKey) {
            loadFromLocalStorage(loadKey);
            closeSavedShowsModal();
          }
          if (delKey) {
            deleteFromLocalStorage(delKey);
            openSavedShowsModal();
          }
        };
        list.addEventListener("click", list._ssHandler);

        document.getElementById("saved-shows-overlay").classList.add("open");
      }

      function closeSavedShowsModal() {
        document.getElementById("saved-shows-overlay").classList.remove("open");
      }

      /* ============================================================
   INIT
   ============================================================ */
      document.addEventListener("DOMContentLoaded", () => {
        elEditorBody = document.getElementById("editor-body");
        elEmptyState = document.getElementById("empty-state");
        elLabelScroll = document.getElementById("label-scroll");
        elTimelineWrap = document.getElementById("timeline-wrap");
        elRulerCanvas = document.getElementById("ruler-canvas");
        elTracks = document.getElementById("tracks-container");
        elPlayhead = document.getElementById("playhead");
        elDragPreview = document.getElementById("drag-preview");
        elStatus = document.getElementById("status-bar");
        elTimeDisplay = document.getElementById("time-display");
        elZoomLabel = document.getElementById("zoom-label");
        elBtnPlay = document.getElementById("btn-play");
        elBtnPause = document.getElementById("btn-pause");
        elBtnStop = document.getElementById("btn-stop");
        elBtnExport = document.getElementById("btn-export");
        elBtnSnap = document.getElementById("btn-snap");
        elSnapLine = document.getElementById("snap-line");

        // File inputs
        function bindFile(id, fn) {
          const el = document.getElementById(id);
          if (el)
            el.addEventListener("change", () => {
              if (el.files[0]) fn(el.files[0]);
            });
        }
        bindFile("json-input", loadShow);
        bindFile("json-input-2", loadShow);
        bindFile("wav-input", loadWAV);

        // New Show buttons + modal
        document
          .getElementById("btn-new-show")
          .addEventListener("click", openNewShowModal);
        document
          .getElementById("btn-new-show-empty")
          .addEventListener("click", openNewShowModal);
        document
          .getElementById("ns-create")
          .addEventListener("click", createNewShow);
        document
          .getElementById("ns-cancel")
          .addEventListener("click", closeNewShowModal);
        document
          .getElementById("new-show-overlay")
          .addEventListener("click", (e) => {
            if (e.target === document.getElementById("new-show-overlay"))
              closeNewShowModal();
          });
        document.getElementById("ns-title").addEventListener("keydown", (e) => {
          if (e.key === "Enter") createNewShow();
          if (e.key === "Escape") closeNewShowModal();
        });

        // Transport
        elBtnPlay.addEventListener("click", startPlayback);
        elBtnPause.addEventListener("click", pausePlayback);
        elBtnStop.addEventListener("click", () => stopPlayback(true));
        elBtnExport.addEventListener("click", exportJSON);
        elBtnSnap.addEventListener("click", toggleSnap);
        document
          .getElementById("btn-save")
          .addEventListener("click", saveToLocalStorage);
        document
          .getElementById("btn-saved-shows")
          .addEventListener("click", openSavedShowsModal);
        document
          .getElementById("ss-close")
          .addEventListener("click", closeSavedShowsModal);
        document
          .getElementById("saved-shows-overlay")
          .addEventListener("click", (e) => {
            if (e.target === document.getElementById("saved-shows-overlay"))
              closeSavedShowsModal();
          });

        // Zoom buttons
        document
          .getElementById("btn-zoom-in")
          .addEventListener("click", () => applyZoom(zoom + 1));
        document
          .getElementById("btn-zoom-out")
          .addEventListener("click", () => applyZoom(zoom - 1));

        // Scroll wheel on timeline â†’ horizontal scroll (DAW-style feel)
        elTimelineWrap.addEventListener(
          "wheel",
          (e) => {
            if (!e.shiftKey && Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
              e.preventDefault();
              elTimelineWrap.scrollLeft += e.deltaY;
            }
          },
          { passive: false },
        );

        // Sync label panel vertical scroll with timeline vertical scroll;
        // also redraw the windowed ruler as horizontal scroll position changes.
        elTimelineWrap.addEventListener("scroll", () => {
          elLabelScroll.scrollTop = elTimelineWrap.scrollTop;
          drawRuler();
        });

        // Redraw ruler when the window is resized (viewport width changes).
        window.addEventListener("resize", () => drawRuler());

        // Ruler click â†’ seek
        elRulerCanvas.addEventListener("click", (e) => {
          if (!showData) return;
          // Canvas is now viewport-wide (windowed), so add scrollLeft to
          // convert the click's canvas-local X into timeline X.
          const frame = xToFrame(e.offsetX + elTimelineWrap.scrollLeft);
          seekToFrame(frame);
          // scroll playhead into view if needed
          elTimelineWrap.scrollLeft = Math.max(
            0,
            frameToX(frame) - elTimelineWrap.clientWidth / 3,
          );
        });

        // Global drag
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);

        // Keyboard shortcuts
        document.addEventListener("keydown", (e) => {
          const tag = document.activeElement.tagName;
          if (tag === "INPUT" || tag === "TEXTAREA") return;

          if (e.code === "Delete" || e.code === "Backspace") {
            e.preventDefault();
            deleteSelected();
          }
          if (e.code === "Space") {
            e.preventDefault();
            if (isPlaying) pausePlayback();
            else startPlayback();
          }
          if (e.code === "Home") seekToFrame(0);
          if (e.code === "End") seekToFrame(totalFrames);
          if (e.code === "ArrowLeft")
            seekToFrame(curFrame - (e.shiftKey ? 50 : 5));
          if (e.code === "ArrowRight")
            seekToFrame(curFrame + (e.shiftKey ? 50 : 5));
          if (e.code === "Equal" || e.code === "NumpadAdd") applyZoom(zoom + 1);
          if (e.code === "Minus" || e.code === "NumpadSubtract")
            applyZoom(zoom - 1);
          if (e.code === "KeyS" && !e.ctrlKey && !e.metaKey) toggleSnap();
          if ((e.ctrlKey || e.metaKey) && e.code === "KeyS") {
            e.preventDefault();
            saveToLocalStorage();
          }
          if ((e.ctrlKey || e.metaKey) && e.code === "KeyC") {
            e.preventDefault();
            copySelected();
          }
          if ((e.ctrlKey || e.metaKey) && e.code === "KeyV") {
            e.preventDefault();
            pasteClipboard();
          }
          if ((e.ctrlKey || e.metaKey) && e.code === "KeyD") {
            e.preventDefault();
            copySelected();
            pasteClipboard();
          }
          if (e.code === "Escape") {
            clearSelection();
            setStatus("Selection cleared.");
          }
        });
      });
    </script>
  </body>
</html>

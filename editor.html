<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cyberstar Show Editor</title>
    <script src="character-movements.js"></script>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      :root {
        --bg: #0d0d1a;
        --panel: #141428;
        --toolbar: #1a1a2e;
        --border: #2a2a44;
        --text: #c8c8e0;
        --muted: #666680;
        --ruler-bg: #111122;
        --row-bg: #12121f;
        --row-alt: #0f0f1c;
        --row-hover: #1a1a30;
        --sel: #ffffff;
        --ruler-h: 44px;
        --label-w: 200px;
        --char-h: 26px;
        --row-h: 22px;
      }

      html,
      body {
        height: 100%;
        background: var(--bg);
        color: var(--text);
        font-family: "Segoe UI", system-ui, sans-serif;
        font-size: 13px;
        overflow: hidden;
      }

      /* â”€â”€ TOOLBAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #toolbar {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 0 12px;
        height: 46px;
        background: var(--toolbar);
        border-bottom: 1px solid var(--border);
        flex-shrink: 0;
        flex-wrap: nowrap;
        overflow: hidden;
      }

      .tb-group {
        display: flex;
        align-items: center;
        gap: 6px;
        border-right: 1px solid var(--border);
        padding-right: 10px;
      }
      .tb-group:last-child {
        border-right: none;
      }

      .tb-title {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
        padding: 0 8px;
      }
      #show-title {
        font-size: 0.95em;
        font-weight: 600;
        color: #ddeeff;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .band-badge {
        font-size: 0.72em;
        padding: 2px 7px;
        border-radius: 10px;
        font-weight: 700;
        letter-spacing: 1px;
        flex-shrink: 0;
      }
      .band-rock {
        background: rgba(0, 200, 255, 0.15);
        color: #00c8ff;
        border: 1px solid #00c8ff44;
      }
      .band-munch {
        background: rgba(255, 80, 80, 0.15);
        color: #ff8080;
        border: 1px solid #ff808044;
      }

      input[type="file"] {
        display: none;
      }

      .tb-btn {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 5px 10px;
        border: 1px solid var(--border);
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        font-size: 0.82em;
        cursor: pointer;
        text-decoration: none;
        white-space: nowrap;
        transition:
          background 0.15s,
          border-color 0.15s;
      }
      .tb-btn:hover {
        background: rgba(255, 255, 255, 0.09);
        border-color: #555;
      }
      .tb-btn:disabled {
        opacity: 0.4;
        cursor: default;
        pointer-events: none;
      }
      .tb-btn-green {
        border-color: rgba(0, 200, 100, 0.4);
        color: #00d464;
        background: rgba(0, 200, 100, 0.07);
      }
      .tb-btn-green:hover {
        background: rgba(0, 200, 100, 0.15);
        border-color: rgba(0, 200, 100, 0.7);
      }

      .time-display {
        font-family: "Courier New", monospace;
        font-size: 0.82em;
        color: #88aacc;
        background: rgba(0, 0, 0, 0.3);
        padding: 4px 10px;
        border-radius: 4px;
        border: 1px solid var(--border);
        min-width: 160px;
        text-align: center;
      }

      #zoom-label {
        font-family: monospace;
        font-size: 0.8em;
        color: var(--muted);
        min-width: 40px;
        text-align: center;
      }

      /* â”€â”€ APP BODY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #app {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      /* â”€â”€ EMPTY STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #empty-state {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .empty-inner {
        text-align: center;
        max-width: 420px;
      }
      .empty-icon {
        font-size: 4em;
        margin-bottom: 16px;
      }
      .empty-inner h2 {
        font-size: 1.4em;
        color: #ddeeff;
        margin-bottom: 10px;
      }
      .empty-inner p {
        color: var(--muted);
        line-height: 1.6;
        margin-bottom: 8px;
      }
      .empty-inner .tb-btn {
        margin-top: 20px;
        font-size: 0.92em;
        padding: 8px 20px;
      }

      /* â”€â”€ EDITOR BODY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #editor-body {
        flex: 1;
        display: none;
        flex-direction: row;
        overflow: hidden;
        min-height: 0;
      }

      /* â”€â”€ LABEL PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #label-panel {
        width: var(--label-w);
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        border-right: 1px solid var(--border);
        background: var(--panel);
        overflow: hidden;
      }
      #label-corner {
        height: var(--ruler-h);
        flex-shrink: 0;
        background: var(--ruler-bg);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: flex-end;
        padding: 0 10px 6px;
      }
      #label-corner span {
        font-size: 0.72em;
        color: var(--muted);
        letter-spacing: 1px;
        text-transform: uppercase;
      }
      #label-scroll {
        flex: 1;
        overflow: hidden;
      }
      .lbl-char-header {
        display: flex;
        align-items: center;
        padding: 0 10px;
        border-bottom: 1px solid;
        font-size: 0.8em;
        font-weight: 700;
        letter-spacing: 0.5px;
        overflow: hidden;
        height: var(--char-h);
        flex-shrink: 0;
      }
      .lbl-move-row {
        display: flex;
        align-items: center;
        padding: 0 10px 0 18px;
        height: var(--row-h);
        font-family: "Courier New", monospace;
        font-size: 0.74em;
        color: var(--muted);
        border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        background: var(--row-bg);
      }
      .lbl-move-row:nth-child(odd) {
        background: var(--row-alt);
      }

      /* â”€â”€ TIMELINE WRAP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #timeline-wrap {
        flex: 1;
        overflow: auto;
        position: relative;
        min-width: 0;
      }

      #ruler-canvas {
        display: block;
        position: sticky;
        top: 0;
        left: 0;
        z-index: 20;
        cursor: crosshair;
      }

      /* â”€â”€ TRACKS CONTAINER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #tracks-container {
        position: relative;
        min-height: 100px;
      }

      .track-char-header {
        height: var(--char-h);
        display: flex;
        align-items: center;
        padding: 0 14px;
        font-size: 0.75em;
        font-weight: 700;
        letter-spacing: 1px;
        text-transform: uppercase;
        border-bottom: 1px solid;
        position: sticky;
        left: 0;
        z-index: 5;
      }

      .track-row {
        height: var(--row-h);
        position: relative;
        border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        background: var(--row-bg);
        cursor: crosshair;
        user-select: none;
      }
      .track-row:nth-child(odd) {
        background: var(--row-alt);
      }
      .track-row:hover {
        background: var(--row-hover);
      }

      .signal-block {
        position: absolute;
        top: 3px;
        height: calc(var(--row-h) - 6px);
        border-radius: 3px;
        cursor: pointer;
        border: 1px solid transparent;
        transition:
          opacity 0.1s,
          border-color 0.1s;
        z-index: 2;
      }
      .signal-block:hover {
        opacity: 1 !important;
        filter: brightness(1.3);
      }
      .signal-block.selected {
        opacity: 1 !important;
        border-color: #fff !important;
        filter: brightness(1.4);
        box-shadow: 0 0 6px rgba(255, 255, 255, 0.4);
      }

      /* â”€â”€ PLAYHEAD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #playhead {
        position: absolute;
        top: 0;
        width: 2px;
        height: 100%;
        background: #ff4444;
        pointer-events: none;
        z-index: 15;
        will-change: left;
      }
      #playhead::before {
        content: "";
        position: absolute;
        top: 0;
        left: -4px;
        border: 5px solid transparent;
        border-top-color: #ff4444;
      }

      /* â”€â”€ DRAG PREVIEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #drag-preview {
        position: absolute;
        top: 0;
        height: 16px;
        background: rgba(255, 255, 255, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.6);
        border-radius: 3px;
        pointer-events: none;
        z-index: 8;
      }

      /* â”€â”€ STATUS BAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #status-bar {
        height: 26px;
        display: flex;
        align-items: center;
        padding: 0 14px;
        background: var(--toolbar);
        border-top: 1px solid var(--border);
        font-size: 0.78em;
        color: var(--muted);
        flex-shrink: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* â”€â”€ HELP TOOLTIP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #help-bar {
        height: 22px;
        display: flex;
        align-items: center;
        padding: 0 14px;
        background: rgba(0, 0, 0, 0.25);
        font-size: 0.73em;
        color: #44445a;
        gap: 16px;
        flex-shrink: 0;
      }
      #help-bar span {
        white-space: nowrap;
      }
      #help-bar kbd {
        background: #1e1e32;
        border: 1px solid #333;
        border-radius: 3px;
        padding: 0 4px;
        font-size: 0.9em;
        color: #888;
      }

      /* scrollbar styling */
      #timeline-wrap::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      #timeline-wrap::-webkit-scrollbar-track {
        background: #0d0d1a;
      }
      #timeline-wrap::-webkit-scrollbar-thumb {
        background: #2a2a44;
        border-radius: 4px;
      }
      #timeline-wrap::-webkit-scrollbar-thumb:hover {
        background: #3a3a60;
      }
      #timeline-wrap::-webkit-scrollbar-corner {
        background: #0d0d1a;
      }

      /* â”€â”€ NEW SHOW MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
      #new-show-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.65);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }
      #new-show-overlay.open {
        display: flex;
      }
      #new-show-modal {
        background: #1a1a2e;
        border: 1px solid #2a2a44;
        border-radius: 10px;
        padding: 28px 32px;
        width: 380px;
        max-width: 95vw;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      }
      #new-show-modal h3 {
        font-size: 1.15em;
        color: #ddeeff;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .ns-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 16px;
      }
      .ns-field label {
        font-size: 0.8em;
        color: #888899;
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }
      .ns-field input,
      .ns-field select {
        background: #0d0d1a;
        border: 1px solid #2a2a44;
        border-radius: 5px;
        color: #c8c8e0;
        padding: 7px 10px;
        font-size: 0.92em;
        outline: none;
        transition: border-color 0.15s;
      }
      .ns-field input:focus,
      .ns-field select:focus {
        border-color: #00c8ff88;
      }
      .ns-dur-row {
        display: flex;
        gap: 8px;
      }
      .ns-dur-row input {
        flex: 1;
        text-align: center;
      }
      .ns-dur-sep {
        align-self: center;
        color: #666680;
        font-size: 1.1em;
      }
      .ns-actions {
        display: flex;
        gap: 10px;
        margin-top: 22px;
      }
      .ns-actions button {
        flex: 1;
        padding: 8px;
        border-radius: 5px;
        border: 1px solid #2a2a44;
        cursor: pointer;
        font-size: 0.88em;
        font-weight: 600;
      }
      #ns-create {
        background: rgba(0, 200, 100, 0.12);
        border-color: rgba(0, 200, 100, 0.4);
        color: #00d464;
      }
      #ns-create:hover {
        background: rgba(0, 200, 100, 0.22);
      }
      #ns-cancel {
        background: rgba(255, 255, 255, 0.04);
        color: #888899;
      }
      #ns-cancel:hover {
        background: rgba(255, 255, 255, 0.09);
      }
    </style>
  </head>
  <body>
    <div id="app">
      <!-- â”€â”€ TOOLBAR â”€â”€ -->
      <div id="toolbar">
        <div class="tb-group">
          <button id="btn-new-show" class="tb-btn tb-btn-green">
            âœš New Show
          </button>
          <label for="json-input" class="tb-btn">ğŸ“‚ Load Show</label>
          <input type="file" id="json-input" accept=".json,.cybershow.json" />
          <label for="wav-input" class="tb-btn">ğŸµ Load WAV</label>
          <input type="file" id="wav-input" accept=".wav,audio/*" />
        </div>

        <div class="tb-title">
          <span id="show-title">No show loaded</span>
          <span id="band-badge" class="band-badge" style="display: none"></span>
        </div>

        <div class="tb-group tb-transport">
          <button id="btn-play" class="tb-btn" disabled>â–¶ Play</button>
          <button id="btn-pause" class="tb-btn" disabled>â¸ Pause</button>
          <button id="btn-stop" class="tb-btn" disabled>â¹ Stop</button>
          <span id="time-display" class="time-display">0:00.000 / F0</span>
        </div>

        <div class="tb-group">
          <button
            id="btn-zoom-out"
            class="tb-btn"
            title="Zoom out (scroll left/right to navigate)"
          >
            âˆ’
          </button>
          <span id="zoom-label">5px/fr</span>
          <button id="btn-zoom-in" class="tb-btn" title="Zoom in">+</button>
        </div>

        <div class="tb-group">
          <button id="btn-export" class="tb-btn tb-btn-green" disabled>
            â¬‡ Export JSON
          </button>
          <a href="index.html" class="tb-btn">â† Simulator</a>
        </div>
      </div>

      <!-- â”€â”€ EMPTY STATE â”€â”€ -->
      <div id="empty-state">
        <div class="empty-inner">
          <div class="empty-icon">ğŸ¬</div>
          <h2>Cyberstar Show Editor</h2>
          <p>
            Start a brand-new show, or open an existing
            <strong>.cybershow.json</strong> file.
          </p>
          <div
            style="
              display: flex;
              gap: 12px;
              justify-content: center;
              margin-top: 22px;
              flex-wrap: wrap;
            "
          >
            <button
              id="btn-new-show-empty"
              class="tb-btn tb-btn-green"
              style="padding: 10px 24px; font-size: 0.95em"
            >
              âœš New Show
            </button>
            <label
              for="json-input-2"
              class="tb-btn"
              style="padding: 10px 24px; font-size: 0.95em; cursor: pointer"
              >ğŸ“‚ Load Show JSON</label
            >
          </div>
          <input type="file" id="json-input-2" accept=".json,.cybershow.json" />
          <p style="margin-top: 18px; font-size: 0.82em">
            Load a WAV file after opening a show to audition while you edit.
          </p>
        </div>
      </div>

      <!-- â”€â”€ EDITOR BODY â”€â”€ -->
      <div id="editor-body">
        <!-- Label column (character names + movement names) -->
        <div id="label-panel">
          <div id="label-corner"><span>Characters</span></div>
          <div id="label-scroll"></div>
        </div>

        <!-- Timeline (ruler + tracks, scrollable) -->
        <div id="timeline-wrap">
          <canvas id="ruler-canvas" title="Click to seek"></canvas>
          <div id="tracks-container">
            <div id="playhead"></div>
            <div id="drag-preview"></div>
          </div>
        </div>
      </div>

      <!-- â”€â”€ NEW SHOW MODAL â”€â”€ -->
      <div id="new-show-overlay">
        <div id="new-show-modal">
          <h3>âœš New Show</h3>
          <div class="ns-field">
            <label for="ns-title">Show Title</label>
            <input
              id="ns-title"
              type="text"
              placeholder="My Cyberstar Show"
              maxlength="80"
            />
          </div>
          <div class="ns-field">
            <label for="ns-band">Band</label>
            <select id="ns-band">
              <option value="rock">Rock-afire Explosion (RFE)</option>
              <option value="munch">Munch's Make Believe Band (MMBB)</option>
            </select>
          </div>
          <div class="ns-field">
            <label>Duration</label>
            <div class="ns-dur-row">
              <input
                id="ns-dur-min"
                type="number"
                min="0"
                max="59"
                value="3"
                title="Minutes"
              />
              <span class="ns-dur-sep">m</span>
              <input
                id="ns-dur-sec"
                type="number"
                min="0"
                max="59"
                value="30"
                title="Seconds"
              />
              <span class="ns-dur-sep">s</span>
            </div>
          </div>
          <div class="ns-actions">
            <button id="ns-create">Create Show</button>
            <button id="ns-cancel">Cancel</button>
          </div>
        </div>
      </div>

      <!-- â”€â”€ HELP BAR â”€â”€ -->
      <div id="help-bar">
        <span><kbd>Click+drag</kbd> empty row â†’ create signal block</span>
        <span><kbd>Click</kbd> block â†’ select</span>
        <span><kbd>Del</kbd> â†’ remove selected</span>
        <span><kbd>Click</kbd> ruler â†’ seek</span>
        <span><kbd>Space</kbd> â†’ play/pause</span>
        <span><kbd>Scroll</kbd> timeline â†’ navigate</span>
      </div>

      <!-- â”€â”€ STATUS BAR â”€â”€ -->
      <div id="status-bar">Ready â€” load a show to begin.</div>
    </div>
    <!-- #app -->

    <script>
      /* ============================================================
   CONSTANTS
   ============================================================ */
      const FPS = 50;
      const MS_PER_FRAME = 1000 / FPS; // 20 ms
      const RULER_H = 44;
      const CHAR_H = 26;
      const ROW_H = 22;

      const BAND_ORDER = {
        rock: [
          "Rolfe",
          "Earl",
          "Dook LaRue",
          "Fatz",
          "Beach Bear",
          "Looney Bird",
          "Mitzi",
          "Billy Bob",
          "Lights",
        ],
        munch: [
          "Chuck E. Cheese",
          "Munch",
          "Helen Henny",
          "Jasper T. Jowls",
          "Pasqually",
        ],
      };

      const CHAR_COLORS = {
        Rolfe: "#00c8ff",
        Earl: "#ff9800",
        "Dook LaRue": "#4caf50",
        Fatz: "#b44ff4",
        "Beach Bear": "#e91e63",
        "Looney Bird": "#ffe000",
        Mitzi: "#ff6e40",
        "Billy Bob": "#00e5cc",
        Lights: "#aaaaaa",
        "Chuck E. Cheese": "#f44336",
        Munch: "#8bc34a",
        "Helen Henny": "#ff80ab",
        "Jasper T. Jowls": "#ffd740",
        Pasqually: "#40c4ff",
      };

      /* ============================================================
   STATE
   ============================================================ */
      let showData = null;
      let audioBuffer = null;
      let audioCtx = null;
      let sourceNode = null;
      let isPlaying = false;
      let playAudioStart = 0; // audioCtx.currentTime at last play start
      let playFrameStart = 0; // show frame at last play start
      let curFrame = 0;
      let zoom = 5; // px per frame
      let totalFrames = 9000;
      let rowMeta = []; // [{ charName, movKey, color }] in display order
      let charMeta = []; // [{ charName, color, movKeys[] }] in display order
      let selectedKey = null; // "charName||movKey||startFrame" or null
      let dragState = null; // { charName, movKey, anchorFrame, curFrame }
      let rafId = null;

      /* ============================================================
   DOM REFS
   ============================================================ */
      let elEditorBody, elEmptyState, elLabelScroll, elTimelineWrap;
      let elRulerCanvas, elTracks, elPlayhead, elDragPreview;
      let elStatus, elTimeDisplay, elZoomLabel;
      let elBtnPlay, elBtnPause, elBtnStop, elBtnExport;

      /* ============================================================
   UTILITIES
   ============================================================ */
      const frameToMs = (f) => f * MS_PER_FRAME;
      const msToFrame = (ms) => Math.round(ms / MS_PER_FRAME);
      const frameToX = (f) => f * zoom;
      const xToFrame = (x) =>
        Math.max(0, Math.min(totalFrames, Math.round(x / zoom)));

      function frameToTimestamp(f) {
        const ms = frameToMs(f);
        const m = Math.floor(ms / 60000);
        const s = String(Math.floor((ms % 60000) / 1000)).padStart(2, "0");
        const ms3 = String(Math.round(ms % 1000)).padStart(3, "0");
        return `${m}:${s}.${ms3}`;
      }

      function setStatus(msg, color) {
        elStatus.textContent = msg;
        elStatus.style.color = color || "";
      }

      /* ============================================================
   SHOW DATA HELPERS
   ============================================================ */
      function getCharSignals(charName, movKey) {
        if (!showData?.characters?.[charName]) return [];
        return showData.characters[charName].signals.filter(
          (s) => s.movement === movKey,
        );
      }

      function ensureChar(charName) {
        if (!showData.characters[charName]) {
          const cEntry = CHARACTER_MOVEMENTS[charName];
          const track = cEntry
            ? Object.values(cEntry.movements)[0].track
            : "TD";
          showData.characters[charName] = { track, signals: [] };
        }
      }

      function getBit(charName, movKey) {
        return CHARACTER_MOVEMENTS[charName]?.movements?.[movKey]?.bit ?? 0;
      }

      /** Pair ONâ†’OFF signals into renderable blocks */
      function getBlocks(charName, movKey) {
        const sigs = getCharSignals(charName, movKey)
          .slice()
          .sort((a, b) => a.frame - b.frame);
        const blocks = [];
        let onFrame = null;
        for (const s of sigs) {
          if (s.state && onFrame === null) {
            onFrame = s.frame;
          } else if (!s.state && onFrame !== null) {
            blocks.push({ startFrame: onFrame, endFrame: s.frame });
            onFrame = null;
          }
        }
        if (onFrame !== null)
          blocks.push({ startFrame: onFrame, endFrame: totalFrames });
        return blocks;
      }

      /* ============================================================
   NEW SHOW
   ============================================================ */
      function openNewShowModal() {
        document.getElementById("new-show-overlay").classList.add("open");
        // Focus title input after transition
        setTimeout(() => document.getElementById("ns-title").focus(), 50);
      }

      function closeNewShowModal() {
        document.getElementById("new-show-overlay").classList.remove("open");
      }

      function createNewShow() {
        const title =
          document.getElementById("ns-title").value.trim() || "Untitled Show";
        const band = document.getElementById("ns-band").value;
        const mins = Math.max(
          0,
          parseInt(document.getElementById("ns-dur-min").value) || 0,
        );
        const secs = Math.max(
          0,
          Math.min(
            59,
            parseInt(document.getElementById("ns-dur-sec").value) || 0,
          ),
        );
        const durationMs = (mins * 60 + secs) * 1000 || 30000; // default 30s if zero
        const frames = msToFrame(durationMs);

        showData = {
          cyberstar_show: true,
          version: "3.0",
          fps: FPS,
          title,
          band,
          duration_frames: frames,
          duration_ms: durationMs,
          characters: {},
        };

        totalFrames = frames;
        closeNewShowModal();
        buildRowMeta(band);
        buildEditor();

        document.getElementById("show-title").textContent = title;
        const badge = document.getElementById("band-badge");
        badge.textContent = band === "munch" ? "MMBB" : "RFE";
        badge.className = `band-badge band-${band}`;
        badge.style.display = "";
        elBtnExport.disabled = false;

        setStatus(
          `New show "${title}" â€” ${frames} frames (${frameToTimestamp(frames)}). Start drawing signal blocks on the timeline.`,
        );
      }

      /* ============================================================
   SHOW LOADING
   ============================================================ */
      function loadShow(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const obj = JSON.parse(e.target.result);
            if (!obj.cyberstar_show)
              throw new Error("Not a valid .cybershow.json file.");

            // Normalise legacy v2.1 (flat sequences[] â†’ characters{})
            if (!obj.characters && Array.isArray(obj.sequences)) {
              obj.characters = {};
              for (const s of obj.sequences) {
                const cEntry = CHARACTER_MOVEMENTS[s.character];
                if (!cEntry?.movements?.[s.movement]) continue;
                if (!obj.characters[s.character]) {
                  obj.characters[s.character] = {
                    track: cEntry.movements[s.movement].track,
                    signals: [],
                  };
                }
                const frame = msToFrame(s.time);
                obj.characters[s.character].signals.push({
                  frame,
                  timestamp: frameToTimestamp(frame),
                  movement: s.movement,
                  bit: cEntry.movements[s.movement].bit,
                  state: s.state,
                  note: s.note || "",
                });
              }
              for (const cd of Object.values(obj.characters)) {
                cd.signals.sort((a, b) => a.frame - b.frame);
              }
            }

            if (!obj.characters)
              throw new Error("No character data found in file.");

            showData = obj;
            totalFrames =
              obj.duration_frames ??
              msToFrame(obj.duration_ms ?? obj.duration ?? 180000);

            const band = obj.band || "rock";
            buildRowMeta(band);
            buildEditor();

            document.getElementById("show-title").textContent =
              obj.title || file.name;
            const badge = document.getElementById("band-badge");
            badge.textContent = band === "munch" ? "MMBB" : "RFE";
            badge.className = `band-badge band-${band}`;
            badge.style.display = "";
            elBtnExport.disabled = false;

            const cueCount = Object.values(obj.characters).reduce(
              (n, c) => n + c.signals.length,
              0,
            );
            setStatus(
              `Loaded "${obj.title || file.name}" â€” ${totalFrames} frames (${frameToTimestamp(totalFrames)}), ${cueCount} signal cues.`,
            );
          } catch (err) {
            setStatus(`âœ— ${err.message}`, "#f44");
          }
        };
        reader.readAsText(file);
      }

      /* ============================================================
   ROW / CHAR META
   ============================================================ */
      function buildRowMeta(band) {
        rowMeta = [];
        charMeta = [];
        const order = BAND_ORDER[band] || Object.keys(CHARACTER_MOVEMENTS);
        for (const charName of order) {
          const cEntry = CHARACTER_MOVEMENTS[charName];
          if (!cEntry) continue;
          const movKeys = Object.keys(cEntry.movements);
          const color = CHAR_COLORS[charName] || "#888899";
          charMeta.push({ charName, color, movKeys });
          for (const movKey of movKeys) {
            rowMeta.push({ charName, movKey, color });
          }
        }
      }

      /* ============================================================
   EDITOR CONSTRUCTION
   ============================================================ */
      function buildEditor() {
        elEditorBody.style.display = "flex";
        elEmptyState.style.display = "none";
        buildLabels();
        buildTracks();
        drawRuler();
        curFrame = 0;
        updatePlayhead();
      }

      function buildLabels() {
        let html = "";
        for (const cm of charMeta) {
          html += `<div class="lbl-char-header" style="height:${CHAR_H}px;border-color:${cm.color}44;background:${cm.color}18;">
               <span style="color:${cm.color};font-size:0.79em;font-weight:700;letter-spacing:.5px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${cm.charName}</span>
             </div>`;
          for (const movKey of cm.movKeys) {
            html += `<div class="lbl-move-row" style="height:${ROW_H}px;">${movKey.replace(/_/g, " ")}</div>`;
          }
        }
        elLabelScroll.innerHTML = html;
      }

      function buildTracks() {
        const totalW = frameToX(totalFrames) + 300;
        elTracks.style.width = totalW + "px";

        // Clear existing tracks but keep playhead + drag-preview
        for (const el of [...elTracks.children]) {
          if (el.id !== "playhead" && el.id !== "drag-preview") el.remove();
        }

        const frag = document.createDocumentFragment();
        for (const cm of charMeta) {
          const hdr = document.createElement("div");
          hdr.className = "track-char-header";
          hdr.style.cssText = `height:${CHAR_H}px;width:${totalW}px;border-color:${cm.color}33;background:${cm.color}0e;color:${cm.color}77;`;
          hdr.textContent = cm.charName;
          frag.appendChild(hdr);

          for (const movKey of cm.movKeys) {
            const row = document.createElement("div");
            row.className = "track-row";
            row.dataset.char = cm.charName;
            row.dataset.mov = movKey;
            row.style.cssText = `height:${ROW_H}px;width:${totalW}px;`;
            row.addEventListener("mousedown", onRowMouseDown);
            frag.appendChild(row);
          }
        }
        elTracks.appendChild(frag);

        // Populate signal blocks
        for (const { charName, movKey, color } of rowMeta) {
          renderBlocks(charName, movKey, color);
        }
      }

      function renderBlocks(charName, movKey, color) {
        const row = elTracks.querySelector(
          `.track-row[data-char="${CSS.escape(charName)}"][data-mov="${CSS.escape(movKey)}"]`,
        );
        if (!row) return;

        for (const b of row.querySelectorAll(".signal-block")) b.remove();

        for (const blk of getBlocks(charName, movKey)) {
          const x = frameToX(blk.startFrame);
          const w = Math.max(3, frameToX(blk.endFrame) - x);
          const key = `${charName}||${movKey}||${blk.startFrame}`;

          const el = document.createElement("div");
          el.className = "signal-block";
          el.dataset.key = key;
          el.style.cssText = `left:${x}px;width:${w}px;background:${color};`;
          el.title = `${charName} / ${movKey.replace(/_/g, " ")}\nON: F${blk.startFrame} (${frameToTimestamp(blk.startFrame)})\nOFF: F${blk.endFrame} (${frameToTimestamp(blk.endFrame)})\nClick to select  Â·  Del to remove`;
          el.addEventListener("mousedown", (e) => {
            e.stopPropagation();
            selectBlock(key, el);
          });
          row.appendChild(el);
        }
      }

      function refreshRow(charName, movKey) {
        const meta = rowMeta.find(
          (r) => r.charName === charName && r.movKey === movKey,
        );
        renderBlocks(charName, movKey, meta?.color || "#888");
      }

      /* ============================================================
   SELECTION
   ============================================================ */
      function selectBlock(key, el) {
        clearSelection();
        selectedKey = key;
        el.classList.add("selected");
        const [cn, mk, sf] = key.split("||");
        setStatus(
          `Selected: ${cn} / ${mk.replace(/_/g, " ")} â€” start frame ${sf} â€” press Delete to remove`,
        );
      }

      function clearSelection() {
        selectedKey = null;
        for (const b of elTracks.querySelectorAll(".signal-block.selected")) {
          b.classList.remove("selected");
        }
      }

      function deleteSelected() {
        if (!selectedKey) return;
        const [charName, movKey, sfStr] = selectedKey.split("||");
        const startFrame = parseInt(sfStr, 10);
        const sigs = showData?.characters?.[charName]?.signals;
        if (!sigs) return;

        // Find ON at startFrame and its matching OFF (first OFF after it for same movement)
        let onIdx = -1,
          offIdx = -1;
        for (let i = 0; i < sigs.length; i++) {
          if (
            sigs[i].movement === movKey &&
            sigs[i].state === true &&
            sigs[i].frame === startFrame
          )
            onIdx = i;
        }
        if (onIdx >= 0) {
          for (let i = onIdx + 1; i < sigs.length; i++) {
            if (sigs[i].movement === movKey && sigs[i].state === false) {
              offIdx = i;
              break;
            }
          }
        }

        const toRemove = [onIdx, offIdx]
          .filter((i) => i >= 0)
          .sort((a, b) => b - a);
        for (const idx of toRemove) sigs.splice(idx, 1);

        clearSelection();
        refreshRow(charName, movKey);
        setStatus(
          `Removed block: ${charName} / ${movKey.replace(/_/g, " ")} at F${startFrame}`,
        );
      }

      /* ============================================================
   DRAG-TO-CREATE
   ============================================================ */
      function onRowMouseDown(e) {
        if (e.button !== 0) return;
        const row = e.currentTarget;
        const charName = row.dataset.char;
        const movKey = row.dataset.mov;
        const rect = row.getBoundingClientRect();
        const rawX = e.clientX - rect.left + elTimelineWrap.scrollLeft;
        const frame = xToFrame(rawX);

        clearSelection();
        dragState = {
          charName,
          movKey,
          anchorFrame: frame,
          curFrame: frame,
          row,
        };
        updateDragPreview(row, frame, frame);
        e.preventDefault();
      }

      function onMouseMove(e) {
        if (!dragState) return;
        const row = dragState.row;
        const rect = row.getBoundingClientRect();
        const rawX = e.clientX - rect.left + elTimelineWrap.scrollLeft;
        dragState.curFrame = xToFrame(rawX);
        const a = Math.min(dragState.anchorFrame, dragState.curFrame);
        const b = Math.max(dragState.anchorFrame, dragState.curFrame);
        updateDragPreview(row, a, b);
      }

      function onMouseUp() {
        if (!dragState) return;
        const { charName, movKey, anchorFrame, curFrame: cf, row } = dragState;
        let startFrame = Math.min(anchorFrame, cf);
        let endFrame = Math.max(anchorFrame, cf);
        if (endFrame - startFrame < 1) endFrame = startFrame + 1;
        endFrame = Math.min(endFrame, totalFrames);

        hideDragPreview();
        dragState = null;

        if (startFrame >= endFrame) return;

        // Overlap check
        const overlaps = getBlocks(charName, movKey).some(
          (b) => startFrame < b.endFrame && endFrame > b.startFrame,
        );
        if (overlaps) {
          setStatus(
            "âš  Cannot place block â€” overlaps an existing signal. Select and delete the existing block first.",
            "#fa0",
          );
          return;
        }

        commitInsert(charName, movKey, startFrame, endFrame);
      }

      function commitInsert(charName, movKey, startFrame, endFrame) {
        ensureChar(charName);
        const bit = getBit(charName, movKey);
        const sigs = showData.characters[charName].signals;
        sigs.push({
          frame: startFrame,
          timestamp: frameToTimestamp(startFrame),
          movement: movKey,
          bit,
          state: true,
          note: "",
        });
        sigs.push({
          frame: endFrame,
          timestamp: frameToTimestamp(endFrame),
          movement: movKey,
          bit,
          state: false,
          note: "",
        });
        sigs.sort((a, b) => a.frame - b.frame || (a.state ? 1 : -1));
        refreshRow(charName, movKey);
        setStatus(
          `Added: ${charName} / ${movKey.replace(/_/g, " ")} F${startFrame}â€“F${endFrame} (${frameToTimestamp(startFrame)} â€“ ${frameToTimestamp(endFrame)})`,
        );
      }

      function updateDragPreview(row, startFrame, endFrame) {
        const x = frameToX(startFrame);
        const w = Math.max(3, frameToX(endFrame) - x);
        elDragPreview.style.display = "block";
        elDragPreview.style.left = x + "px";
        elDragPreview.style.top = row.offsetTop + 3 + "px";
        elDragPreview.style.width = w + "px";
        elDragPreview.style.height = ROW_H - 6 + "px";
      }

      function hideDragPreview() {
        elDragPreview.style.display = "none";
      }

      /* ============================================================
   RULER  (windowed â€“ canvas is only viewport-wide to avoid the
           ~65 535 px browser canvas hardware limit)
   ============================================================ */
      function drawRuler() {
        const canvas = elRulerCanvas;

        // Width = visible viewport only; full timeline width lives in
        // elTracks.style.width so the scrollbar stays correct.
        const viewW = Math.max(100, elTimelineWrap.clientWidth || 800);
        const scrollX = elTimelineWrap.scrollLeft || 0;

        canvas.width = viewW; // safe â€” never exceeds screen width
        canvas.height = RULER_H;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#111122";
        ctx.fillRect(0, 0, viewW, RULER_H);

        // Choose a nice tick interval so major ticks are ~80â€“200px apart
        const pxPerSec = zoom * FPS;
        const secOptions = [0.1, 0.2, 0.5, 1, 2, 5, 10, 30, 60];
        const majorSec = secOptions.find((s) => s * pxPerSec >= 80) ?? 60;
        const minorSec = majorSec / 4;
        const majorF = Math.round(majorSec * FPS);
        const minorF = Math.max(1, Math.round(minorSec * FPS));

        // Only iterate over frames that are actually visible
        const firstVisF = Math.max(
          0,
          Math.floor(xToFrame(scrollX) / minorF) * minorF - minorF,
        );
        const lastVisF = Math.min(
          totalFrames + majorF,
          Math.ceil(xToFrame(scrollX + viewW) / minorF) * minorF + minorF,
        );

        ctx.lineWidth = 1;
        for (let f = firstVisF; f <= lastVisF; f += minorF) {
          // Offset by scrollX so ticks land at the correct visual position
          const x = frameToX(f) - scrollX + 0.5;
          const isMajor = f % majorF === 0;

          ctx.strokeStyle = isMajor ? "#4a4a6a" : "#252538";
          ctx.beginPath();
          ctx.moveTo(x, RULER_H);
          ctx.lineTo(x, isMajor ? RULER_H - 18 : RULER_H - 8);
          ctx.stroke();

          if (isMajor) {
            const ms = frameToMs(f);
            const m = Math.floor(ms / 60000);
            const s = String(Math.floor((ms % 60000) / 1000)).padStart(2, "0");
            const ms3 = String(Math.round(ms % 1000)).padStart(3, "0");
            ctx.fillStyle = "#9090b8";
            ctx.font = `11px 'Courier New', monospace`;
            ctx.textAlign = "left";
            ctx.fillText(`${m}:${s}`, x + 3, 14);
            ctx.fillStyle = "#44445a";
            ctx.fillText(`F${f}`, x + 3, 28);
          }
        }

        // Bottom edge line (spans the viewport, not the whole timeline)
        ctx.strokeStyle = "#22223a";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, RULER_H - 0.5);
        ctx.lineTo(viewW, RULER_H - 0.5);
        ctx.stroke();
      }

      /* ============================================================
   PLAYHEAD
   ============================================================ */
      function updatePlayhead() {
        elPlayhead.style.left = frameToX(curFrame) + "px";
        const ms = frameToMs(curFrame);
        const m = Math.floor(ms / 60000);
        const s = String(Math.floor((ms % 60000) / 1000)).padStart(2, "0");
        const ms3 = String(Math.round(ms % 1000)).padStart(3, "0");
        elTimeDisplay.textContent = `${m}:${s}.${ms3}  /  F${curFrame}`;
      }

      function seekToFrame(frame) {
        const wasPlaying = isPlaying;
        if (wasPlaying) stopPlayback(false);
        curFrame = Math.max(0, Math.min(totalFrames, frame));
        updatePlayhead();
        if (wasPlaying) startPlayback();
      }

      /* ============================================================
   AUDIO
   ============================================================ */
      function getAudioCtx() {
        if (!audioCtx || audioCtx.state === "closed")
          audioCtx = new AudioContext();
        return audioCtx;
      }

      function loadWAV(file) {
        setStatus("Decoding audioâ€¦");
        const reader = new FileReader();
        reader.onload = (e) => {
          getAudioCtx()
            .decodeAudioData(e.target.result.slice(0))
            .then((buf) => {
              audioBuffer = buf;
              enableTransport(true);
              setStatus(
                `WAV loaded: ${buf.duration.toFixed(2)}s â€” ${buf.numberOfChannels}ch @ ${buf.sampleRate}Hz`,
              );
            })
            .catch(() =>
              setStatus(
                "âœ— Could not decode audio. Use a standard WAV file.",
                "#f44",
              ),
            );
        };
        reader.readAsArrayBuffer(file);
      }

      function enableTransport(on) {
        elBtnPlay.disabled = !on;
        elBtnPause.disabled = !on;
        elBtnStop.disabled = !on;
      }

      function startPlayback() {
        if (!audioBuffer) {
          setStatus("Load a WAV file to enable playback.", "#fa0");
          return;
        }
        const ctx = getAudioCtx();
        const offsetS = frameToMs(curFrame) / 1000;
        if (offsetS >= audioBuffer.duration) {
          stopPlayback();
          return;
        }

        if (sourceNode) {
          try {
            sourceNode.stop();
          } catch (_) {}
        }
        sourceNode = ctx.createBufferSource();
        sourceNode.buffer = audioBuffer;
        sourceNode.connect(ctx.destination);
        sourceNode.start(0, offsetS);
        sourceNode.onended = () => {
          isPlaying = false;
          cancelAnimationFrame(rafId);
        };

        playAudioStart = ctx.currentTime;
        playFrameStart = curFrame;
        isPlaying = true;

        const tick = () => {
          const elapsed = ctx.currentTime - playAudioStart;
          curFrame = Math.min(
            totalFrames,
            playFrameStart + msToFrame(elapsed * 1000),
          );
          updatePlayhead();

          // Auto-scroll playhead into view
          const phX = frameToX(curFrame);
          const wLeft = elTimelineWrap.scrollLeft;
          const wW = elTimelineWrap.clientWidth;
          if (phX > wLeft + wW - 80 || phX < wLeft) {
            elTimelineWrap.scrollLeft = phX - 60;
          }

          if (isPlaying && curFrame < totalFrames)
            rafId = requestAnimationFrame(tick);
        };
        rafId = requestAnimationFrame(tick);
      }

      function pausePlayback() {
        if (!isPlaying) return;
        isPlaying = false;
        cancelAnimationFrame(rafId);
        if (sourceNode) {
          try {
            sourceNode.stop();
          } catch (_) {}
          sourceNode = null;
        }
      }

      function stopPlayback(resetFrame = true) {
        pausePlayback();
        if (resetFrame) {
          curFrame = 0;
          updatePlayhead();
        }
      }

      /* ============================================================
   ZOOM
   ============================================================ */
      function applyZoom(newZoom) {
        const anchorFrame = curFrame;
        zoom = Math.max(1, Math.min(40, newZoom));
        elZoomLabel.textContent = `${zoom}px/fr`;

        const totalW = frameToX(totalFrames) + 300;
        elTracks.style.width = totalW + "px";
        for (const el of elTracks.querySelectorAll(
          ".track-row, .track-char-header",
        )) {
          el.style.width = totalW + "px";
        }

        drawRuler();
        for (const { charName, movKey, color } of rowMeta)
          renderBlocks(charName, movKey, color);
        updatePlayhead();

        // Keep the current playhead roughly centred after zoom
        elTimelineWrap.scrollLeft = Math.max(
          0,
          frameToX(anchorFrame) - elTimelineWrap.clientWidth / 2,
        );
      }

      /* ============================================================
   EXPORT
   ============================================================ */
      function exportJSON() {
        if (!showData) return;

        // Refresh timestamps
        for (const cd of Object.values(showData.characters)) {
          for (const sig of cd.signals)
            sig.timestamp = frameToTimestamp(sig.frame);
        }
        showData.version = "3.0";
        showData.fps = FPS;
        showData.duration_frames = totalFrames;
        showData.duration_ms = frameToMs(totalFrames);

        const json = JSON.stringify(showData, null, 2);
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${(showData.title || "show").replace(/[^a-z0-9_\-]/gi, "_")}.cybershow.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 10000);

        const total = Object.values(showData.characters).reduce(
          (n, c) => n + Math.floor(c.signals.filter((s) => s.state).length),
          0,
        );
        setStatus(`Exported "${showData.title}" â€” ${total} ON signals.`);
      }

      /* ============================================================
   INIT
   ============================================================ */
      document.addEventListener("DOMContentLoaded", () => {
        elEditorBody = document.getElementById("editor-body");
        elEmptyState = document.getElementById("empty-state");
        elLabelScroll = document.getElementById("label-scroll");
        elTimelineWrap = document.getElementById("timeline-wrap");
        elRulerCanvas = document.getElementById("ruler-canvas");
        elTracks = document.getElementById("tracks-container");
        elPlayhead = document.getElementById("playhead");
        elDragPreview = document.getElementById("drag-preview");
        elStatus = document.getElementById("status-bar");
        elTimeDisplay = document.getElementById("time-display");
        elZoomLabel = document.getElementById("zoom-label");
        elBtnPlay = document.getElementById("btn-play");
        elBtnPause = document.getElementById("btn-pause");
        elBtnStop = document.getElementById("btn-stop");
        elBtnExport = document.getElementById("btn-export");

        // File inputs
        function bindFile(id, fn) {
          const el = document.getElementById(id);
          if (el)
            el.addEventListener("change", () => {
              if (el.files[0]) fn(el.files[0]);
            });
        }
        bindFile("json-input", loadShow);
        bindFile("json-input-2", loadShow);
        bindFile("wav-input", loadWAV);

        // New Show buttons + modal
        document
          .getElementById("btn-new-show")
          .addEventListener("click", openNewShowModal);
        document
          .getElementById("btn-new-show-empty")
          .addEventListener("click", openNewShowModal);
        document
          .getElementById("ns-create")
          .addEventListener("click", createNewShow);
        document
          .getElementById("ns-cancel")
          .addEventListener("click", closeNewShowModal);
        document
          .getElementById("new-show-overlay")
          .addEventListener("click", (e) => {
            if (e.target === document.getElementById("new-show-overlay"))
              closeNewShowModal();
          });
        document.getElementById("ns-title").addEventListener("keydown", (e) => {
          if (e.key === "Enter") createNewShow();
          if (e.key === "Escape") closeNewShowModal();
        });

        // Transport
        elBtnPlay.addEventListener("click", startPlayback);
        elBtnPause.addEventListener("click", pausePlayback);
        elBtnStop.addEventListener("click", () => stopPlayback(true));
        elBtnExport.addEventListener("click", exportJSON);

        // Zoom buttons
        document
          .getElementById("btn-zoom-in")
          .addEventListener("click", () => applyZoom(zoom + 1));
        document
          .getElementById("btn-zoom-out")
          .addEventListener("click", () => applyZoom(zoom - 1));

        // Scroll wheel on timeline â†’ horizontal scroll (DAW-style feel)
        elTimelineWrap.addEventListener(
          "wheel",
          (e) => {
            if (!e.shiftKey && Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
              e.preventDefault();
              elTimelineWrap.scrollLeft += e.deltaY;
            }
          },
          { passive: false },
        );

        // Sync label panel vertical scroll with timeline vertical scroll;
        // also redraw the windowed ruler as horizontal scroll position changes.
        elTimelineWrap.addEventListener("scroll", () => {
          elLabelScroll.scrollTop = elTimelineWrap.scrollTop;
          drawRuler();
        });

        // Redraw ruler when the window is resized (viewport width changes).
        window.addEventListener("resize", () => drawRuler());

        // Ruler click â†’ seek
        elRulerCanvas.addEventListener("click", (e) => {
          if (!showData) return;
          // Canvas is now viewport-wide (windowed), so add scrollLeft to
          // convert the click's canvas-local X into timeline X.
          const frame = xToFrame(e.offsetX + elTimelineWrap.scrollLeft);
          seekToFrame(frame);
          // scroll playhead into view if needed
          elTimelineWrap.scrollLeft = Math.max(
            0,
            frameToX(frame) - elTimelineWrap.clientWidth / 3,
          );
        });

        // Global drag
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);

        // Keyboard shortcuts
        document.addEventListener("keydown", (e) => {
          const tag = document.activeElement.tagName;
          if (tag === "INPUT" || tag === "TEXTAREA") return;

          if (e.code === "Delete" || e.code === "Backspace") {
            e.preventDefault();
            deleteSelected();
          }
          if (e.code === "Space") {
            e.preventDefault();
            if (isPlaying) pausePlayback();
            else startPlayback();
          }
          if (e.code === "Home") seekToFrame(0);
          if (e.code === "End") seekToFrame(totalFrames);
          if (e.code === "ArrowLeft")
            seekToFrame(curFrame - (e.shiftKey ? 50 : 5));
          if (e.code === "ArrowRight")
            seekToFrame(curFrame + (e.shiftKey ? 50 : 5));
          if (e.code === "Equal" || e.code === "NumpadAdd") applyZoom(zoom + 1);
          if (e.code === "Minus" || e.code === "NumpadSubtract")
            applyZoom(zoom - 1);
        });
      });
    </script>
  </body>
</html>

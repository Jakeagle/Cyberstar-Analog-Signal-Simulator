# SGM Validation History — The Road to Hardware-Conformant Output

This page documents the history of the signal generation pipeline, including a significant early failure, the investigation that followed, and the architectural decision to move generation to Python.

---

## The Problem: Old Web Audio API Export (Pre-Python)

The original signal export pipeline was written entirely in JavaScript, using the Web Audio API's `AudioWorkletProcessor` to generate BMC frames in real time and capture them to a WAV file.

### Why It Failed

A validation test (using `SCME/SVM/validate.py`) was run against a WAV generated by the old pipeline. Here is the actual failure report from the system:

```
CYBERSTAR HARDWARE EMULATOR -- FAILURE REPORT
====================================================
Generated  : 2026-02-27 11:15:48
File       : Hip_to_be_square_-_Decoder_test_4ch.wav
Sample Rate: 48000 Hz  (4-channel legacy Cyberstar format)

RESULT: FAIL

Reason (TD track):
  - Frame sync: NO LOCK
  - Blank-bit integrity: 80.3%  (required >= 98.0%)

Reason (BD track):
  - Frame sync: NO LOCK
  - Blank-bit integrity: 91.2%  (required >= 98.0%)

Root cause:
  The WAV was generated by the old Web Audio API export pipeline.
  The output did not conform to the BMC frame structure expected
  by the hardware. Frame boundaries could not be established on
  either the TD or BD control tracks. This file would be rejected
  by physical Cyberstar hardware.

Next step:
  Re-export using the Python SCME/SGM pipeline (BMCEncoder +
  FrameBuilder). Python-generated output passed 100% of internal
  validation tests and produces hardware-conformant BMC frames.
```

### Root Cause Analysis

Several issues were identified:

1. **Wrong sample rate in test file**: The WAV was at 48,000 Hz instead of 44,100 Hz. At 48,000 Hz, a 4,800 baud signal would require exactly 10.0 samples per bit — but the encoder was using 10 samples/bit optimised for 44,100 Hz (where it should be 9). The resulting timing was wrong for both sample rates.

2. **Float32 rounding in BMC level generation**: The Web Audio API works in Float32 internally. When the square-wave amplitude was near ±1.0 and converted to Int16, floating-point precision caused some samples to land at values like +32766 or -32767 instead of the exact ±32767/-32768. This produced run-length jitter.

3. **Frame boundary timing drift**: The Web Audio API's `AudioWorkletProcessor` clock is subject to minor timing jitter under load. Over a 4-minute show, this accumulated enough drift to misalign frame boundaries, causing the sync-byte detection to jump to wrong positions.

4. **Blank bits not enforced**: The old JS encoder didn't explicitly zero out blank bits before encoding. In some edge cases, stale buffer values left blank bits as `1`.

---

## The Fix: Python Signal Generation Module (SGM)

The solution was to move all signal generation to Python, running via Pyodide in the browser for export.

### Why Python Solved It

1. **Exact integer arithmetic**: Python's `//` operator always produces a true integer. No float accumulation in the bit timing.

2. **Stateful encoder**: `BMCEncoder` is a class that keeps the current output level as an integer across frames. Every bit transition is exact. There is no clock to drift.

3. **Explicit blank-bit enforcement**: `FrameBuilder` explicitly zeroes positions 56, 65, 70 (TD) and 45 (BD) before encoding every frame.

4. **Sample rate is a constant, not a runtime parameter**: `constants.py` hardcodes `SAMPLE_RATE = 44_100`. If a non-44100 Hz WAV appears, the system rejects it at the earliest point.

5. **Deterministic output**: The same input produces the exact same byte-for-byte output every time. The Web Audio API path was non-deterministic under load.

### Validation After the Fix

After switching to the Python SGM, `validate.py` results:

```
TEST 1 — Constants Integrity
  [PASS] SAMPLE_RATE = 44100
  [PASS] BAUD_RATE = 4800
  [PASS] SAMPLES_PER_BIT = 9
  [PASS] HALF_A + HALF_B = SPB
  [PASS] TD: no duplicate bit numbers
  [PASS] TD: blanks not in channel map
  [PASS] BD: no duplicate bit numbers
  [PASS] BD: blanks not in channel map

TEST 2 — BMC Encoder
  [PASS] Bit-0 produces single run of SAMPLES_PER_BIT
  [PASS] Bit-1 produces two runs summing to SAMPLES_PER_BIT
  [PASS] Level alternates between HIGH and LOW correctly

TEST 3 — Frame Builder
  [PASS] Frame builds without error for 100 random events
  [PASS] Blank bits are 0 in all frames
  [PASS] Sync byte is 0xFF in all frames

TEST 4 — KWS Cross-Check
  [PASS] Run-length profile matches KWS bimodal distribution (within 5%)

RESULT: 0 failures
```

---

## Lessons Learned

1. **The Web Audio API is not a real-time precise encoder.** It is excellent for playback and decoding, but should not be used for generating safety-critical binary signals that must match hardware timing precisely.

2. **Validation before integration.** The failure was caught by the automated validator, not by testing on real hardware. This is why `SCME/SVM/validate.py` and `SViz/visualizer_bridge.py` exist and must be run on every export.

3. **Keep constants in one place.** The old JS encoder and Python encoder had separate copies of timing constants that drifted out of sync. Now all constants live in `SCME/SMM/constants.py` as the single source of truth, inlined into browser-only Python files where needed.

4. **Pyodide makes Python-in-browser viable.** The performance cost (~5–20 seconds for SGM on a typical desktop) is acceptable for an export operation that happens once per show. Real-time preview still runs in JS.
